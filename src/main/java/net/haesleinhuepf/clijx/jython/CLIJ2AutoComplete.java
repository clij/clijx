package net.haesleinhuepf.clijx.jython;
import org.fife.ui.autocomplete.BasicCompletion;
import net.haesleinhuepf.clijx.jython.ScriptingAutoCompleteProvider;
import java.util.ArrayList;// this is generated code. See src/test/java/net/haesleinhuepf/clijx/codegenerator for details
class CLIJ2AutoComplete {
   
   public static ArrayList<BasicCompletion> getCompletions(final ScriptingAutoCompleteProvider provider) {
       ArrayList<BasicCompletion> list = new ArrayList<BasicCompletion>();
       String headline;
       String description;
       headline = "clij2.absolute(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>absolute</b><br><br>Computes the absolute value of every individual pixel x in a given image.<br><br><pre>f(x) = |x| </pre><br><br>### Parameters<br><br>source : Image<br>    The input image to be processed.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.absoluteDifference(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination)";
       description = "<b>absoluteDifference</b><br><br>Determines the absolute difference pixel by pixel between two images.<br><br><pre>f(x, y) = |x - y| </pre><br><br>### Parameters<br><br>source1 : Image<br>    The input image to be subtracted from.<br>source2 : Image<br>    The input image which is subtracted.<br>destination : Image<br>    The output image  where results are written into.<br><br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.addImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>addImageAndScalar</b><br><br>Adds a scalar value s to all pixels x of a given image X.<br><br><pre>f(x, s) = x + s</pre><br><br>### Parameters<br><br>source : Image<br>    The input image where scalare should be added.<br>destination : Image<br>    The output image where results are written into.<br>scalar : float<br>    The constant number which will be added to all pixels.<br><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.addImages(ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination)";
       description = "<b>addImages</b><br><br>Calculates the sum of pairs of pixels x and y of two images X and Y.<br><br><pre>f(x, y) = x + y</pre><br><br>### Parameters<br><br>summand1 : Image<br>    The first input image to added.<br>summand2 : Image<br>    The second image to be added.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.addImagesWeighted(ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination, Float factor1, Float factor2)";
       description = "<b>addImagesWeighted</b><br><br>Calculates the sum of pairs of pixels x and y from images X and Y weighted with factors a and b.<br><br><pre>f(x, y, a, b) = x * a + y * b</pre><br><br>### Parameters<br><br>summand1 : Image<br>    The first input image to added.<br>summand2 : Image<br>    The second image to be added.<br>destination : Image<br>    The output image where results are written into.<br>factor1 : float<br>    The constant number which will be multiplied with each pixel of summand1 before adding it.<br>factor2 : float<br>    The constant number which will be multiplied with each pixel of summand2 before adding it.<br><br><br>Parameters:<br>ClearCLImageInterface summand1, ClearCLImageInterface summand2, ClearCLImageInterface destination, Float factor1, Float factor2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.adjacencyMatrixToTouchMatrix(ClearCLBuffer adjacency_matrix, ClearCLBuffer touch_matrix)";
       description = "<b>adjacencyMatrixToTouchMatrix</b><br><br>Converts a adjacency matrix in a touch matrix.<br><br>An adjacency matrix is symmetric while a touch matrix is typically not.<br><br>### Parameters<br><br>adjacency_matrix : Image<br>    The input adjacency matrix to be read from.<br>touch_matrix : Image<br>    The output touch matrix to be written into.<br><br><br>Parameters:<br>ClearCLBuffer adjacency_matrix, ClearCLBuffer touch_matrix";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.affineTransform(null)";
       description = "<b>affineTransform</b><br><br>Applies an affine transform to a 3D image.<br><br>The transform describes how coordinates in the target image are transformed to coordinates in the source image.<br>This may appear unintuitive and will be changed in the next major release. The replacement <br>affineTransform (currently part of CLIJx) will apply inverted transforms compared to this operation.<br>Individual transforms must be separated by spaces.<br>Parameters<br>----------<br>source : Image<br>    The input image to be processed.<br>destination : Image<br>    The output image where results are written into.<br>transform : String<br>    A space-separated list of individual transforms. Syntrax see below.<br><br>Supported transforms:<br><br>* -center: translate the coordinate origin to the center of the image<br>* center: translate the coordinate origin back to the initial origin<br>* rotate=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* rotateX=[angle]: rotate in Y/Z plane (around X-axis) by the given angle in degrees<br>* rotateY=[angle]: rotate in X/Z plane (around Y-axis) by the given angle in degrees<br>* rotateZ=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* scale=[factor]: isotropic scaling according to given zoom factor<br>* scaleX=[factor]: scaling along X-axis according to given zoom factor<br>* scaleY=[factor]: scaling along Y-axis according to given zoom factor<br>* scaleZ=[factor]: scaling along Z-axis according to given zoom factor<br>* shearXY=[factor]: shearing along X-axis in XY plane according to given factor<br>* shearXZ=[factor]: shearing along X-axis in XZ plane according to given factor<br>* shearYX=[factor]: shearing along Y-axis in XY plane according to given factor<br>* shearYZ=[factor]: shearing along Y-axis in YZ plane according to given factor<br>* shearZX=[factor]: shearing along Z-axis in XZ plane according to given factor<br>* shearZY=[factor]: shearing along Z-axis in YZ plane according to given factor<br>* translateX=[distance]: translate along X-axis by distance given in pixels<br>* translateY=[distance]: translate along X-axis by distance given in pixels<br>* translateZ=[distance]: translate along X-axis by distance given in pixels<br><br>Example transform:<br>transform = &quot;-center scale=2 rotate=45 center&quot;;<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.affineTransform2D(ClearCLBuffer source, ClearCLImageInterface destination, String transform)";
       description = "<b>affineTransform2D</b><br><br>Applies an affine transform to a 2D image.<br><br>The transform describes how coordinates in the target image are transformed to coordinates in the source image.<br>This may appear unintuitive and will be changed in the next major release. The replacement <br>affineTransform (currently part of CLIJx) will apply inverted transforms compared to this operation.<br>Individual transforms must be separated by spaces.<br>### Parameters<br><br>source : Image<br>    The input image to be processed.<br>destination : Image<br>    The output image where results are written into.<br>transform : String<br>    A space-separated list of individual transforms. Syntrax see below.<br><br>Supported transforms:<br><br>* -center: translate the coordinate origin to the center of the image<br>* center: translate the coordinate origin back to the initial origin<br>* rotate=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* scale=[factor]: isotropic scaling according to given zoom factor<br>* scaleX=[factor]: scaling along X-axis according to given zoom factor<br>* scaleY=[factor]: scaling along Y-axis according to given zoom factor<br>* shearXY=[factor]: shearing along X-axis in XY plane according to given factor<br>* translateX=[distance]: translate along X-axis by distance given in pixels<br>* translateY=[distance]: translate along X-axis by distance given in pixels<br><br>Example transform:<br>transform = &quot;-center scale=2 rotate=45 center&quot;;<br><br>Parameters:<br>ClearCLBuffer source, ClearCLImageInterface destination, String transform";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.affineTransform3D(ClearCLBuffer source, ClearCLImageInterface destination, String transform)";
       description = "<b>affineTransform3D</b><br><br>Applies an affine transform to a 3D image.<br><br>The transform describes how coordinates in the target image are transformed to coordinates in the source image.<br>This may appear unintuitive and will be changed in the next major release. The replacement <br>affineTransform (currently part of CLIJx) will apply inverted transforms compared to this operation.<br>Individual transforms must be separated by spaces.<br>### Parameters<br><br>source : Image<br>    The input image to be processed.<br>destination : Image<br>    The output image where results are written into.<br>transform : String<br>    A space-separated list of individual transforms. Syntrax see below.<br><br>Supported transforms:<br><br>* -center: translate the coordinate origin to the center of the image<br>* center: translate the coordinate origin back to the initial origin<br>* rotate=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* rotateX=[angle]: rotate in Y/Z plane (around X-axis) by the given angle in degrees<br>* rotateY=[angle]: rotate in X/Z plane (around Y-axis) by the given angle in degrees<br>* rotateZ=[angle]: rotate in X/Y plane (around Z-axis) by the given angle in degrees<br>* scale=[factor]: isotropic scaling according to given zoom factor<br>* scaleX=[factor]: scaling along X-axis according to given zoom factor<br>* scaleY=[factor]: scaling along Y-axis according to given zoom factor<br>* scaleZ=[factor]: scaling along Z-axis according to given zoom factor<br>* shearXY=[factor]: shearing along X-axis in XY plane according to given factor<br>* shearXZ=[factor]: shearing along X-axis in XZ plane according to given factor<br>* shearYX=[factor]: shearing along Y-axis in XY plane according to given factor<br>* shearYZ=[factor]: shearing along Y-axis in YZ plane according to given factor<br>* shearZX=[factor]: shearing along Z-axis in XZ plane according to given factor<br>* shearZY=[factor]: shearing along Z-axis in YZ plane according to given factor<br>* translateX=[distance]: translate along X-axis by distance given in pixels<br>* translateY=[distance]: translate along X-axis by distance given in pixels<br>* translateZ=[distance]: translate along X-axis by distance given in pixels<br><br>Example transform:<br>transform = &quot;-center scale=2 rotate=45 center&quot;;<br><br>Parameters:<br>ClearCLBuffer source, ClearCLImageInterface destination, String transform";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.applyVectorField(ClearCLImageInterface source, ClearCLImageInterface vector_x, ClearCLImageInterface vector_y, ClearCLImageInterface destination)";
       description = "<b>applyVectorField</b><br><br>Deforms an image according to distances provided in the given vector images.<br><br> It is recommended to use 32-bit images for input, output and vector images.<br><br>### Parameters<br><br>source : Image<br>    The input image to be processed.<br>vector_x : Image<br>    Pixels in this image describe the distance in X direction pixels should be shifted during warping.<br>vector_y : Image<br>    Pixels in this image describe the distance in Y direction pixels should be shifted during warping.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface vector_x, ClearCLImageInterface vector_y, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.applyVectorField2D(ClearCLImageInterface source, ClearCLImageInterface vector_x, ClearCLImageInterface vector_y, ClearCLImageInterface destination)";
       description = "<b>applyVectorField2D</b><br><br>Deforms an image according to distances provided in the given vector images.<br><br> It is recommended to use 32-bit images for input, output and vector images.<br><br>### Parameters<br><br>source : Image<br>    The input image to be processed.<br>vector_x : Image<br>    Pixels in this image describe the distance in X direction pixels should be shifted during warping.<br>vector_y : Image<br>    Pixels in this image describe the distance in Y direction pixels should be shifted during warping.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface vector_x, ClearCLImageInterface vector_y, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.applyVectorField3D(ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface vectorZ, ClearCLImageInterface destination)";
       description = "<b>applyVectorField3D</b><br><br>Deforms an image stack according to distances provided in the given vector image stacks.<br><br>It is recommended to use 32-bit image stacks for input, output and vector image stacks.<br><br>### Parameters<br><br>source : Image<br>    The input image to be processed.<br>vector_x : Image<br>    Pixels in this image describe the distance in X direction pixels should be shifted during warping.<br>vector_y : Image<br>    Pixels in this image describe the distance in Y direction pixels should be shifted during warping.<br>vector_z : Image<br>    Pixels in this image describe the distance in Z direction pixels should be shifted during warping.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface vectorX, ClearCLImageInterface vectorY, ClearCLImageInterface vectorZ, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.argMaximumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max, ClearCLImageInterface destination_arg_max)";
       description = "<b>argMaximumZProjection</b><br><br>Determines the maximum projection of an image stack along Z.<br><br>Furthermore, another 2D image is generated with pixels containing the z-index where the maximum was found (zero based).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max, ClearCLImageInterface destination_arg_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.automaticThreshold(ClearCLBuffer input, ClearCLBuffer destination, String method)";
       description = "<b>automaticThreshold</b><br><br>The automatic thresholder utilizes the threshold methods from ImageJ on a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br> Enter one <br>of these methods in the method text field:<br>[Default, Huang, Intermodes, IsoData, IJ_IsoData, Li, MaxEntropy, Mean, MinError, Minimum, Moments, Otsu, Percentile, RenyiEntropy, Shanbhag, Triangle, Yen]<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, String method";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.averageDistanceOfClosestPoints(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>averageDistanceOfClosestPoints</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.averageDistanceOfNClosestNeighborsMap(ClearCLBuffer input, ClearCLBuffer destination, Integer n)";
       description = "<b>averageDistanceOfNClosestNeighborsMap</b><br><br>Takes a label map, determines distances between all centroids and replaces every label with the average distance to the n closest neighboring labels.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer n";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.averageDistanceOfNClosestPoints(ClearCLBuffer distance_matrix, ClearCLBuffer distance_list_destination, Integer n_closest_points_to_find)";
       description = "<b>averageDistanceOfNClosestPoints</b><br><br>Determines the average of the n closest points for every point in a distance matrix.<br><br>This corresponds to the average of the n minimum values (rows) for each column of the distance matrix.<br><br>### Parameters<br><br>distance_matrix : Image<br>    The a distance matrix to be processed.<br>distance_list_destination : Image<br>    A vector image with the same width as the distance matrix and height=1, depth=1.<br>    Determined average distances will be written into this vector.<br>n_closest_points_to_find : Number<br>    Number of smallest distances which should be averaged.<br><br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer distance_list_destination, Integer n_closest_points_to_find";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.averageDistanceOfNFarOffPoints(ClearCLBuffer distance_matrix, ClearCLBuffer distance+_list_destination, Integer n_far_off_points_to_find)";
       description = "<b>averageDistanceOfNFarOffPoints</b><br><br>Determines the average of the n far off (most distant) points for every point in a distance matrix.<br><br>This corresponds to the average of the n maximum values (rows) for each column of the distance matrix.<br><br>### Parameters<br><br>distance_matrix : Image<br>    The a distance matrix to be processed.<br>distance_list_destination : Image<br>    A vector image with the same width as the distance matrix and height=1, depth=1.<br>    Determined average distances will be written into this vector.<br>n_far_off_points_to_find : Number<br>    Number of largest distances which should be averaged.<br><br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer distance+_list_destination, Integer n_far_off_points_to_find";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.averageDistanceOfTouchingNeighbors(ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer average_distancelist_destination)";
       description = "<b>averageDistanceOfTouchingNeighbors</b><br><br>Takes a touch matrix and a distance matrix to determine the average distance of touching neighbors <br> for every object.<br><br>### Parameters<br><br>distance_matrix : Image<br>    The a distance matrix to be processed.<br>touch_matrix : Image<br>    The binary touch matrix describing which distances should be taken into account.<br>distance_list_destination : Image<br>    A vector image with the same width as the distance matrix and height=1, depth=1.<br>    Determined average distances will be written into this vector.<br><br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer average_distancelist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.averageNeighborDistanceMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>averageNeighborDistanceMap</b><br><br>Takes a label map, determines which labels touch and replaces every label with the average distance to their neighboring labels.<br><br>To determine the distances, the centroid of the labels is determined internally.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.binaryAnd(ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination)";
       description = "<b>binaryAnd</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary AND operator &.<br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = x & y</pre><br><br>### Parameters<br><br>operand1 : Image<br>    The first binary input image to be processed.<br>operand2 : Image<br>    The second binary input image to be processed.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.binaryEdgeDetection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>binaryEdgeDetection</b><br><br>Determines pixels/voxels which are on the surface of binary objects and sets only them to 1 in the <br>destination image. All other pixels are set to 0.<br><br>### Parameters<br><br>source : Image<br>    The binary input image where edges will be searched.<br>destination : Image<br>    The output image where edge pixels will be 1.<br><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.binaryFillHoles(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>binaryFillHoles</b><br><br>Fills holes (pixels with value 0 surrounded by pixels with value 1) in a binary image.<br><br>Note: This function is known to perform slowly on large images. Consider using the extension <br>CLIJx_morphoLibJFillHoles(input, destination) instead.<br>Read more: http://clij.github.io/assistant/installation#extensions<br><br>### Parameters<br><br>source : Image<br>    The binary input image where holes will be filled.<br>destination : Image<br>    The output image where true pixels will be 1.<br><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.binaryIntersection(ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination)";
       description = "<b>binaryIntersection</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary intersection operator &.<br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = x & y</pre><br><br>### Parameters<br><br>operand1 : Image<br>    The first binary input image to be processed.<br>operand2 : Image<br>    The second binary input image to be processed.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.binaryNot(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>binaryNot</b><br><br>Computes a binary image (containing pixel values 0 and 1) from an image X by negating its pixel values<br>x using the binary NOT operator !<br><br>All pixel values except 0 in the input image are interpreted as 1.<br><br><pre>f(x) = !x</pre><br><br>### Parameters<br><br>source : Image<br>    The binary input image to be inverted.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.binaryOr(ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination)";
       description = "<b>binaryOr</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary OR operator |.<br><br>All pixel values except 0 in the input images are interpreted as 1.<pre>f(x, y) = x | y</pre><br><br>### Parameters<br><br>operand1 : Image<br>    The first binary input image to be processed.<br>operand2 : Image<br>    The second binary input image to be processed.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.binarySubtract(ClearCLImageInterface minuend, ClearCLImageInterface subtrahend, ClearCLImageInterface destination)";
       description = "<b>binarySubtract</b><br><br>Subtracts one binary image from another.<br><br>### Parameters<br><br>minuend : Image<br>    The first binary input image to be processed.<br>suubtrahend : Image<br>    The second binary input image to be subtracted from the first.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLImageInterface minuend, ClearCLImageInterface subtrahend, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.binaryUnion(ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination)";
       description = "<b>binaryUnion</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary union operator |.<br><br>All pixel values except 0 in the input images are interpreted as 1.<pre>f(x, y) = x | y</pre><br><br>### Parameters<br><br>operand1 : Image<br>    The first binary input image to be processed.<br>operand2 : Image<br>    The second binary input image to be processed.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLBuffer operand1, ClearCLBuffer operand2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.binaryXOr(ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination)";
       description = "<b>binaryXOr</b><br><br>Computes a binary image (containing pixel values 0 and 1) from two images X and Y by connecting pairs of<br>pixels x and y with the binary operators AND &, OR | and NOT ! implementing the XOR operator.<br><br>All pixel values except 0 in the input images are interpreted as 1.<br><br><pre>f(x, y) = (x & !y) | (!x & y)</pre><br><br>### Parameters<br><br>operand1 : Image<br>    The first binary input image to be processed.<br>operand2 : Image<br>    The second binary input image to be processed.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLImageInterface operand1, ClearCLImageInterface operand2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.bottomHatBox(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>bottomHatBox</b><br><br>Apply a bottom-hat filter for background subtraction to the input image.<br><br>### Parameters<br><br>input : Image<br>    The input image where the background is subtracted from.<br>destination : Image<br>    The output image where results are written into.<br>radius_x : Image<br>    Radius of the background determination region in X.<br>radius_y : Image<br>    Radius of the background determination region in Y.<br>radius_z : Image<br>    Radius of the background determination region in Z.<br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.bottomHatSphere(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>bottomHatSphere</b><br><br>Applies a bottom-hat filter for background subtraction to the input image.<br><br>### Parameters<br><br>input : Image<br>    The input image where the background is subtracted from.<br>destination : Image<br>    The output image where results are written into.<br>radius_x : Image<br>    Radius of the background determination region in X.<br>radius_y : Image<br>    Radius of the background determination region in Y.<br>radius_z : Image<br>    Radius of the background determination region in Z.<br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.boundingBox(ClearCLBuffer source)";
       description = "<b>boundingBox</b><br><br>Determines the bounding box of all non-zero pixels in a binary image. <br><br>If called from macro, the positions will be stored in a new row of ImageJs Results table in the columns 'BoundingBoxX', 'BoundingBoxY', 'BoundingBoxZ', 'BoundingBoxWidth', 'BoundingBoxHeight' 'BoundingBoxDepth'.In case of 2D images Z and depth will be zero.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.centerOfMass(ClearCLBuffer source)";
       description = "<b>centerOfMass</b><br><br>Determines the center of mass of an image or image stack. <br><br>It writes the result in the results table<br>in the columns MassX, MassY and MassZ.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.centroidsOfBackgroundAndLabels(ClearCLBuffer source, ClearCLBuffer pointlist_destination)";
       description = "<b>centroidsOfBackgroundAndLabels</b><br><br>Determines the centroids of the background and all labels in a label image or image stack. <br><br>It writes the resulting  coordinates in a pointlist image. Depending on the dimensionality d of the labelmap and the number  of labels n, the pointlist image will have n*d pixels.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer pointlist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.centroidsOfLabels(ClearCLBuffer source, ClearCLBuffer pointlist_destination)";
       description = "<b>centroidsOfLabels</b><br><br>Determines the centroids of all labels in a label image or image stack. <br><br>It writes the resulting  coordinates in a pointlist image. Depending on the dimensionality d of the labelmap and the number  of labels n, the pointlist image will have n*d pixels.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer pointlist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.clInfo(null)";
       description = "<b>clInfo</b><br><br>Outputs information about available OpenCL devices.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.clear(null)";
       description = "<b>clear</b><br><br>Resets the GPUs memory by deleting all cached images.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.closeIndexGapsInLabelMap(ClearCLBuffer labeling_input, ClearCLImageInterface labeling_destination)";
       description = "<b>closeIndexGapsInLabelMap</b><br><br>Analyses a label map and if there are gaps in the indexing (e.g. label 5 is not present) all <br>subsequent labels will be relabelled. <br><br>Thus, afterwards number of labels and maximum label index are equal.<br>This operation is mostly performed on the CPU.<br><br>Parameters:<br>ClearCLBuffer labeling_input, ClearCLImageInterface labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.closingBox(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_dilations_and_erosions)";
       description = "<b>closingBox</b><br><br>Apply a binary closing to the input image by calling n dilations and n erosions subsequenntly.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_dilations_and_erosions";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.closingDiamond(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_dilations_and_erotions)";
       description = "<b>closingDiamond</b><br><br>Apply a binary closing to the input image by calling n dilations and n erosions subsequently.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_dilations_and_erotions";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.combineHorizontally(ClearCLImageInterface stack1, ClearCLImageInterface stack2, ClearCLImageInterface destination)";
       description = "<b>combineHorizontally</b><br><br>Combines two images or stacks in X.<br><br>Parameters:<br>ClearCLImageInterface stack1, ClearCLImageInterface stack2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.combineVertically(ClearCLImageInterface stack1, ClearCLImageInterface stack2, ClearCLImageInterface destination)";
       description = "<b>combineVertically</b><br><br>Combines two images or stacks in Y.<br><br>Parameters:<br>ClearCLImageInterface stack1, ClearCLImageInterface stack2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.concatenateStacks(ClearCLImageInterface stack1, ClearCLImageInterface stack2, ClearCLImageInterface destination)";
       description = "<b>concatenateStacks</b><br><br>Concatenates two stacks in Z.<br><br>Parameters:<br>ClearCLImageInterface stack1, ClearCLImageInterface stack2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.connectedComponentsLabelingBox(ClearCLImageInterface binary_input, ClearCLImageInterface labeling_destination)";
       description = "<b>connectedComponentsLabelingBox</b><br><br>Performs connected components analysis inspecting the box neighborhood of every pixel to a binary image and generates a label map.<br><br>Parameters:<br>ClearCLImageInterface binary_input, ClearCLImageInterface labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.connectedComponentsLabelingDiamond(ClearCLImageInterface binary_input, ClearCLImageInterface labeling_destination)";
       description = "<b>connectedComponentsLabelingDiamond</b><br><br>Performs connected components analysis inspecting the diamond neighborhood of every pixel to a binary image and generates a label map.<br><br>Parameters:<br>ClearCLImageInterface binary_input, ClearCLImageInterface labeling_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.convertFloat(null)";
       description = "<b>convertFloat</b><br><br>Convert the input image to a float image with 32 bits per pixel.<br><br>The target image should not exist with a different type before this <br>method is called.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.convertUInt16(null)";
       description = "<b>convertUInt16</b><br><br>Convert the input image to a unsigned integer image with 16 bits per pixel.<br><br>Pixel values are copied as they are. Use multiplyImageWithScalar in order to scalepixel values when reducing bit-depth to prevent cutting-off intensity ranges.<br>The target image should not exist with a different type before this <br>method is called.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.convertUInt8(null)";
       description = "<b>convertUInt8</b><br><br>Convert the input image to a unsigned integer image with 8 bits per pixel.<br><br>Pixel values are copied as they are. Use multiplyImageWithScalar in order to scalepixel values when reducing bit-depth to prevent cutting-off intensity ranges.<br>The target image should not exist with a different type before this <br>method is called.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.convolve(ClearCLBuffer source, ClearCLBuffer convolution_kernel, ClearCLBuffer destination)";
       description = "<b>convolve</b><br><br>Convolve the image with a given kernel image.<br><br>It is recommended that the kernel image has an odd size in X, Y and Z.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer convolution_kernel, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.copy(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>copy</b><br><br>Copies an image.<br><br><pre>f(x) = x</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.copySlice(ClearCLImageInterface source, ClearCLImageInterface destination, Integer slice_index)";
       description = "<b>copySlice</b><br><br>This method has two purposes: <br>It copies a 2D image to a given slice z position in a 3D image stack or <br>It copies a given slice at position z in an image stack to a 2D image.<br><br>The first case is only available via ImageJ macro. If you are using it, it is recommended that the <br>target 3D image already pre-exists in GPU memory before calling this method. Otherwise, CLIJ create <br>the image stack with z planes.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer slice_index";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.cosinus(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>cosinus</b><br><br>Computes the cosinus of all pixels value x.<br><br><pre>f(x) = cos(x)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.countNonZeroPixels(ClearCLBuffer source)";
       description = "<b>countNonZeroPixels</b><br><br>Determines the number of all pixels in a given image which are not equal to 0. <br><br>It will be stored in a new row of ImageJs<br>Results table in the column 'CountNonZero'.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.countNonZeroPixels2DSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY)";
       description = "<b>countNonZeroPixels2DSphere</b><br><br>Counts non-zero pixels in a sphere around every pixel. <br><br>Put the number in the result image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.countNonZeroPixelsLocally(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4)";
       description = "<b>countNonZeroPixelsLocally</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.countNonZeroPixelsLocallySliceBySlice(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4)";
       description = "<b>countNonZeroPixelsLocallySliceBySlice</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.countNonZeroPixelsSliceBySliceSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY)";
       description = "<b>countNonZeroPixelsSliceBySliceSphere</b><br><br>Counts non-zero pixels in a sphere around every pixel slice by slice in a stack. <br><br> It puts the resulting number in the destination image stack.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.countNonZeroVoxels3DSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>countNonZeroVoxels3DSphere</b><br><br>Counts non-zero voxels in a sphere around every voxel. <br><br>Put the number in the result image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.countNonZeroVoxelsLocally(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>countNonZeroVoxelsLocally</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.countTouchingNeighbors(ClearCLBuffer touch_matrix, ClearCLBuffer touching_neighbors_count_destination)";
       description = "<b>countTouchingNeighbors</b><br><br>Takes a touch matrix as input and delivers a vector with number of touching neighbors per label as a vector.<br><br>Parameters:<br>ClearCLBuffer touch_matrix, ClearCLBuffer touching_neighbors_count_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.create2D(null)";
       description = "<b>create2D</b><br><br>Allocated memory for a new 2D image in the GPU memory.<br><br>Parameters<br>----------<br>destination : Image<br>    The new image will be stored in this variable.<br>width : Number<br>    The width of the new image.<br>height : Number<br>    The height of the new image.<br>bit-depth : Number<br>    The bit-depth of the new image. Can be either 8, 16 or 32, to create an image of unsigned-byte, unsigned-short or float type.<br><br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.create3D(null)";
       description = "<b>create3D</b><br><br>Allocated memory for a new 3D image in the GPU memory.<br><br>Parameters<br>----------<br>destination : Image<br>    The new image will be stored in this variable.<br>width : Number<br>    The width of the new image.<br>height : Number<br>    The height of the new image.<br>depth : Number<br>    The depth of the new image.<br>bit-depth : Number<br>    The bit-depth of the new image. Can be either 8, 16 or 32, to create an image of unsigned-byte, unsigned-short or float type.<br><br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.crop(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>crop</b><br><br>Crops a given rectangle out of a given image. <br><br>Note: If the destination image pre-exists already, it will be overwritten and keep it's dimensions.<br><br>### Parameters<br><br>source : Image<br>    The image where a part will be cropped out.<br>destination : Image<br>    The cropped image will be stored in this variable.<br>start_x : Number<br>    The horizontal position of the region to crop in the source image.<br>start_y : Number<br>    The vertical position of the region to crop in the source image.<br>width : Number<br>    The width of the region to crop in the source image.<br>height : Number<br>    The height of the region to crop in the source image.<br><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.crop2D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4)";
       description = "<b>crop2D</b><br><br>Crops a given rectangle out of a given image. <br><br>Note: If the destination image pre-exists already, it will be overwritten and keep it's dimensions.<br><br>### Parameters<br><br>source : Image<br>    The image where a part will be cropped out.<br>destination : Image<br>    The cropped image will be stored in this variable.<br>start_x : Number<br>    The horizontal position of the region to crop in the source image.<br>start_y : Number<br>    The vertical position of the region to crop in the source image.<br>width : Number<br>    The width of the region to crop in the source image.<br>height : Number<br>    The height of the region to crop in the source image.<br><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.crop3D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>crop3D</b><br><br>Crops a given sub-stack out of a given image stack. <br><br>Note: If the destination image pre-exists already, it will be overwritten and keep it's dimensions.<br><br>### Parameters<br><br>source : Image<br>    The image where a part will be cropped out.<br>destination : Image<br>    The cropped image will be stored in this variable.<br>start_x : Number<br>    The horizontal position of the region to crop in the source image.<br>start_y : Number<br>    The vertical position of the region to crop in the source image.<br>start_z : Number<br>    The slice position of the region to crop in the source image. Slices are counted 0-based; the first slice is z=0.<br>width : Number<br>    The width of the region to crop in the source image.<br>height : Number<br>    The height of the region to crop in the source image.<br>depth : Number<br>    The depth of the region to crop in the source image.<br><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.customOperation(String arg1, String arg2, HashMap arg3)";
       description = "<b>customOperation</b><br><br>Executes a custom operation wirtten in OpenCL on a custom list of images. <br><br>All images must be created before calling this method. Image parameters should be handed over as an array with parameter names and image names alternating, e.g.<br><br>Ext.CLIJ2_customOperation(..., ..., newArray(&quot;image1&quot;, &quot;blobs.gif&quot;, &quot;image2&quot;, &quot;Processed_blobs.gif&quot;))<br><br>In the custom code, you can use the predefined variables x, y and z to deal with coordinates.<br>You can for example use it to access pixel intensities like this:<br><br>float value = READ_IMAGE(image, sampler, POS_image_INSTANCE(x, y, z, 0)).x;<br>WRITE_IMAGE(image, POS_image_INSTANCE(x, y, z, 0), CONVERT_image_PIXEL_TYPE(value));<br><br>Note: replace `image` with the given image parameter name. You can furthermore use custom function to organise code in the global_code parameter. In OpenCL they may look like this:<br><br>inline float sum(float a, float b) {<br>    return a + b;<br>}<br><br><br>Parameters:<br>String arg1, String arg2, HashMap arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.cylinderTransform(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_angles, Float delta_angle_in_degrees, Float relative_center_x, Float relative_center_z)";
       description = "<b>cylinderTransform</b><br><br>Applies a cylinder transform to an image stack assuming the center line goes in Y direction in the center of the stack.<br><br>This transforms an image stack from an XYZ coordinate system to a AYD coordinate system with <br>A the angle around the center line, <br>Y the original Y coordinate and <br>D, the distance from the center.<br><br>Thus, going in virtual Z direction (actually D) in the resulting stack, you go from the center to theperiphery.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_angles, Float delta_angle_in_degrees, Float relative_center_x, Float relative_center_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.depthColorProjection(ClearCLImageInterface source, ClearCLBuffer lookup_table, ClearCLBuffer destination_max, Float min_display_intensity, Float max_display_intensity)";
       description = "<b>depthColorProjection</b><br><br>Determines a maximum projection of an image stack and does a color coding of the determined arg Z (position of the found maximum). <br><br>Second parameter is a Lookup-Table in the form of an 8-bit image stack 255 pixels wide, 1 pixel high with 3 planes representing red, green and blue intensities.<br>Resulting image is a 3D image with three Z-planes representing red, green and blue channels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLBuffer lookup_table, ClearCLBuffer destination_max, Float min_display_intensity, Float max_display_intensity";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.detectLabelEdges(ClearCLImageInterface label_map, ClearCLBuffer edge_image_destination)";
       description = "<b>detectLabelEdges</b><br><br>Takes a labelmap and returns an image where all pixels on label edges are set to 1 and all other pixels to 0.<br><br>### Parameters<br><br>label_map : Image<br>    The label image where edges between labels will be detected.<br>edge_image_destination : Number<br>    Binary image where edges were marked with value 1 and all other pixels will be set to 0.<br><br><br>Parameters:<br>ClearCLImageInterface label_map, ClearCLBuffer edge_image_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.detectMaxima2DBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY)";
       description = "<b>detectMaxima2DBox</b><br><br>Detects local maxima in a given square/cubic neighborhood. <br><br>Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a <br>higher intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.detectMaxima3DBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>detectMaxima3DBox</b><br><br>Detects local maxima in a given square/cubic neighborhood. <br><br>Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a <br>higher intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.detectMaximaBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius)";
       description = "<b>detectMaximaBox</b><br><br>Detects local maxima in a given square/cubic neighborhood. <br><br>Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a <br>higher intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.detectMaximaSliceBySliceBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY)";
       description = "<b>detectMaximaSliceBySliceBox</b><br><br>Detects local maxima in a given square neighborhood of an input image stack. <br><br>The input image stack is processed slice by slice. Pixels in the resulting image are set to 1 if <br>there is no other pixel in a given radius which has a higher intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.detectMinima2DBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY)";
       description = "<b>detectMinima2DBox</b><br><br>Detects local minima in a given square/cubic neighborhood. <br><br>Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a <br>lower intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.detectMinima3DBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>detectMinima3DBox</b><br><br>Detects local minima in a given square/cubic neighborhood. <br><br>Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a <br>lower intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.detectMinimaBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius)";
       description = "<b>detectMinimaBox</b><br><br>Detects local minima in a given square/cubic neighborhood. <br><br>Pixels in the resulting image are set to 1 if there is no other pixel in a given radius which has a <br>lower intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.detectMinimaSliceBySliceBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer RadiusY)";
       description = "<b>detectMinimaSliceBySliceBox</b><br><br>Detects local minima in a given square neighborhood of an input image stack. <br><br>The input image stack is processed slice by slice. Pixels in the resulting image are set to 1 if <br>there is no other pixel in a given radius which has a lower intensity, and to 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radiusX, Integer RadiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.differenceOfGaussian(ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma2x, Float sigma2y)";
       description = "<b>differenceOfGaussian</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>### Parameters<br><br>input : Image<br>    The input image to be processed.<br>destination : Image<br>    The output image where results are written into.<br>sigma1_x : float<br>    Sigma of the first Gaussian filter in x<br>sigma1_y : float<br>    Sigma of the first Gaussian filter in y<br>sigma2_x : float<br>    Sigma of the second Gaussian filter in x<br>sigma2_y : float<br>    Sigma of the second Gaussian filter in y<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma2x, Float sigma2y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.differenceOfGaussian2D(ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma2x, Float sigma2y)";
       description = "<b>differenceOfGaussian2D</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>### Parameters<br><br>input : Image<br>    The input image to be processed.<br>destination : Image<br>    The output image where results are written into.<br>sigma1_x : float<br>    Sigma of the first Gaussian filter in x<br>sigma1_y : float<br>    Sigma of the first Gaussian filter in y<br>sigma2_x : float<br>    Sigma of the second Gaussian filter in x<br>sigma2_y : float<br>    Sigma of the second Gaussian filter in y<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma2x, Float sigma2y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.differenceOfGaussian3D(ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma1z, Float sigma2x, Float sigma2y, Float sigma2z)";
       description = "<b>differenceOfGaussian3D</b><br><br>Applies Gaussian blur to the input image twice with different sigma values resulting in two images which are then subtracted from each other.<br><br>It is recommended to apply this operation to images of type Float (32 bit) as results might be negative.<br><br>### Parameters<br><br>input : Image<br>    The input image to be processed.<br>destination : Image<br>    The output image where results are written into.<br>sigma1_x : float<br>    Sigma of the first Gaussian filter in x<br>sigma1_y : float<br>    Sigma of the first Gaussian filter in y<br>sigma1_z : float<br>    Sigma of the first Gaussian filter in z<br>sigma2_x : float<br>    Sigma of the second Gaussian filter in x<br>sigma2_y : float<br>    Sigma of the second Gaussian filter in y<br>sigma2_z : float<br>    Sigma of the second Gaussian filter in z<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float sigma1x, Float sigma1y, Float sigma1z, Float sigma2x, Float sigma2y, Float sigma2z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.different(ClearCLBuffer input_image1, ClearCLBuffer input_image2, ClearCLBuffer binary_destination, Float tolerance)";
       description = "<b>different</b><br><br>Determines the absolute difference between two images and sets all pixels to 1 where it is above a given tolerance, and 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer input_image1, ClearCLBuffer input_image2, ClearCLBuffer binary_destination, Float tolerance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.dilateBox(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateBox</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br><br>The dilation takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Dilate' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.dilateBoxSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateBoxSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br><br>The dilation takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Dilate' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.dilateLabels(ClearCLBuffer input, ClearCLBuffer destination, Integer radius)";
       description = "<b>dilateLabels</b><br><br>Extend labels with a given radius.<br><br>This is actually a local maximum filter applied to a label map which does not overwrite labels.<br>It is recommended to apply this operation to isotropic images only.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radius";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.dilateSphere(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateSphere</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br><br>The dilation takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.dilateSphereSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>dilateSphereSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary dilation of a given input image.<br><br>The dilation takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.distanceMap(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>distanceMap</b><br><br>Generates a distance map from a binary image. <br><br>Pixels with non-zero value in the binary image are set to a number representing the distance to the closest zero-value pixel.<br><br>Note: This function is known to be slow. See the web for alternatives: <br>Note: This is not a distance matrix. See generateDistanceMatrix for details.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.distanceMatrixToMesh(ClearCLBuffer pointlist, ClearCLBuffer distance_matrix, ClearCLBuffer mesh_destination, Float maximum_distance)";
       description = "<b>distanceMatrixToMesh</b><br><br>Generates a mesh from a distance matric and a list of point coordinates.<br><br>Takes a pointlist with dimensions n*d with n point coordinates in d dimensions and a distance matrix of size n*n to draw lines from all points to points if the corresponding pixel in the distance matrix is smaller than a given distance threshold.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer distance_matrix, ClearCLBuffer mesh_destination, Float maximum_distance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.divideByGaussianBackground(ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ)";
       description = "<b>divideByGaussianBackground</b><br><br>Applies Gaussian blur to the input image and divides the original by the result.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float sigmaX, Float sigmaY, Float sigmaZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.divideImages(ClearCLImageInterface divident, ClearCLImageInterface divisor, ClearCLImageInterface destination)";
       description = "<b>divideImages</b><br><br>Divides two images X and Y by each other pixel wise. <br><br><pre>f(x, y) = x / y</pre><br><br>Parameters:<br>ClearCLImageInterface divident, ClearCLImageInterface divisor, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.divideScalarByImage(ClearCLImageInterface image, ClearCLImageInterface destination, Float scalar)";
       description = "<b>divideScalarByImage</b><br><br>Divides a scalar s by image X pixel wise. <br><br><pre>f(s, x) = s / x</pre><br><br>Parameters:<br>ClearCLImageInterface image, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.downsample(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY)";
       description = "<b>downsample</b><br><br>Scales an image using given scaling factors for X and Y dimensions. <br><br>The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.downsample2D(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY)";
       description = "<b>downsample2D</b><br><br>Scales an image using given scaling factors for X and Y dimensions. <br><br>The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.downsample3D(ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY, Float factorZ)";
       description = "<b>downsample3D</b><br><br>Scales an image using given scaling factors for X and Y dimensions. <br><br>The nearest-neighbor method<br>is applied. In ImageJ the method which is similar is called 'Interpolation method: none'.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factorX, Float factorY, Float factorZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.downsampleSliceBySliceHalfMedian(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>downsampleSliceBySliceHalfMedian</b><br><br>Scales an image using scaling factors 0.5 for X and Y dimensions. The Z dimension stays untouched. <br><br>Thus, each slice is processed separately.<br>The median method is applied. Thus, each pixel value in the destination image equals to the median of<br>four corresponding pixels in the source image.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.drawBox(ClearCLImageInterface destination, Float x, Float y, Float z, Float width, Float height, Float depth, Float value)";
       description = "<b>drawBox</b><br><br>Draws a box at a given start point with given size. <br>All pixels other than in the box are untouched. Consider using `set(buffer, 0);` in advance.<br><br>Parameters:<br>ClearCLImageInterface destination, Float x, Float y, Float z, Float width, Float height, Float depth, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.drawDistanceMeshBetweenTouchingLabels(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>drawDistanceMeshBetweenTouchingLabels</b><br><br>Starting from a label map, draw lines between touching neighbors resulting in a mesh.<br><br>The end points of the lines correspond to the centroids of the labels. The intensity of the lines <br>corresponds to the distance between these labels (in pixels or voxels).<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.drawLine(ClearCLImageInterface destination, Float x1, Float y1, Float z1, Float x2, Float y2, Float z2, Float thickness, Float value)";
       description = "<b>drawLine</b><br><br>Draws a line between two points with a given thickness. <br><br>All pixels other than on the line are untouched. Consider using `set(buffer, 0);` in advance.<br><br>Parameters:<br>ClearCLImageInterface destination, Float x1, Float y1, Float z1, Float x2, Float y2, Float z2, Float thickness, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.drawMeshBetweenNClosestLabels(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_closest_labels)";
       description = "<b>drawMeshBetweenNClosestLabels</b><br><br>Starting from a label map, draw lines between n closest labels for each label resulting in a mesh.<br><br>The end points of the lines correspond to the centroids of the labels. <br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_closest_labels";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.drawMeshBetweenNNearestLabels(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_closest_labels)";
       description = "<b>drawMeshBetweenNNearestLabels</b><br><br>Starting from a label map, draw lines between n closest labels for each label resulting in a mesh.<br><br>The end points of the lines correspond to the centroids of the labels. <br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_closest_labels";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.drawMeshBetweenProximalLabels(ClearCLBuffer input, ClearCLBuffer destination, Float maximum_distance)";
       description = "<b>drawMeshBetweenProximalLabels</b><br><br>Starting from a label map, draw lines between labels that are closer than a given distance resulting in a mesh.<br><br>The end points of the lines correspond to the centroids of the labels.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float maximum_distance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.drawMeshBetweenTouchingLabels(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>drawMeshBetweenTouchingLabels</b><br><br>Starting from a label map, draw lines between touching neighbors resulting in a mesh.<br><br>The end points of the lines correspond to the centroids of the labels. <br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.drawSphere(ClearCLImageInterface destination, Float x, Float y, Float z, Float radius_x, Float radius_y, Float radius_z, Float value)";
       description = "<b>drawSphere</b><br><br>Draws a sphere around a given point with given radii in x, y and z (if 3D). <br><br> All pixels other than in the sphere are untouched. Consider using `set(buffer, 0);` in advance.<br><br>Parameters:<br>ClearCLImageInterface destination, Float x, Float y, Float z, Float radius_x, Float radius_y, Float radius_z, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.entropyBox(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>entropyBox</b><br><br>Determines the local entropy in a box with a given radius around every pixel.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.equal(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>equal</b><br><br>Determines if two images A and B equal pixel wise.<br><br><pre>f(a, b) = 1 if a == b; 0 otherwise.</pre><br><br>### Parameters<br><br>source1 : Image<br>    The first image to be compared with.<br>source2 : Image<br>    The second image to be compared with the first.<br>destination : Image<br>    The resulting binary image where pixels will be 1 only if source1 and source2 equal in the given pixel.<br><br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.equalConstant(ClearCLImageInterface source, ClearCLImageInterface destination, Float constant)";
       description = "<b>equalConstant</b><br><br>Determines if an image A and a constant b are equal.<br><br><pre>f(a, b) = 1 if a == b; 0 otherwise.</pre><br><br>### Parameters<br><br>source : Image<br>    The image where every pixel is compared to the constant.<br>destination : Image<br>    The resulting binary image where pixels will be 1 only if source1 and source2 equal in the given pixel.<br>constant : float<br>    The constant where every pixel is compared to.<br><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.equalizeMeanIntensitiesOfSlices(ClearCLBuffer input, ClearCLBuffer destination, Integer referenceSlice)";
       description = "<b>equalizeMeanIntensitiesOfSlices</b><br><br>Determines correction factors for each z-slice so that the average intensity in all slices can be made the same and multiplies these factors with the slices. <br><br>This functionality is similar to the 'Simple Ratio Bleaching Correction' in Fiji.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer referenceSlice";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.erodeBox(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeBox</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image. <br><br>The erosion takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Erode' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.erodeBoxSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeBoxSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image. <br><br>The erosion takes the Moore-neighborhood (8 pixels in 2D and 26 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This method is comparable to the 'Erode' menu in ImageJ in case it is applied to a 2D image. The only<br>difference is that the output image contains values 0 and 1 instead of 0 and 255.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.erodeLabels(ClearCLBuffer labels_input, ClearCLBuffer labels_destination, Integer radius, Boolean relabel_islands)";
       description = "<b>erodeLabels</b><br><br>Extend labels with a given radius.<br><br>This is actually a local minimum filter applied to a label map after introducing background-gaps between labels.<br>In case relabel_islands is set, split objects will get new labels each. In this case, more labels might be in the result.<br>It is recommended to apply this operation to isotropic images only.<br>Warning: If labels were too small, they may be missing in the resulting label image.<br><br>Parameters:<br>ClearCLBuffer labels_input, ClearCLBuffer labels_destination, Integer radius, Boolean relabel_islands";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.erodeSphere(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeSphere</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image. <br><br>The erosion takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.erodeSphereSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>erodeSphereSliceBySlice</b><br><br>Computes a binary image with pixel values 0 and 1 containing the binary erosion of a given input image. <br><br>The erosion takes the von-Neumann-neighborhood (4 pixels in 2D and 6 pixels in 3d) into account.<br>The pixels in the input image with pixel value not equal to 0 will be interpreted as 1.<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.euclideanDistanceFromLabelCentroidMap(ClearCLBuffer labelmap_input, ClearCLBuffer destination)";
       description = "<b>euclideanDistanceFromLabelCentroidMap</b><br><br>Takes a label map, determines the centroids of all labels and writes the distance of all labelled pixels to their centroid in the result image.<br>Background pixels stay zero.<br><br>Parameters:<br>ClearCLBuffer labelmap_input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.excludeLabels(ClearCLBuffer binary_flaglist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination)";
       description = "<b>excludeLabels</b><br><br>This operation removes labels from a labelmap and renumbers the remaining labels. <br><br>Hand over a binary flag list vector starting with a flag for the background, continuing with label1, label2, ...<br><br>For example if you pass 0,1,0,0,1: Labels 1 and 4 will be removed (those with a 1 in the vector will be excluded). Labels 2 and 3 will be kept and renumbered to 1 and 2.<br><br>Parameters:<br>ClearCLBuffer binary_flaglist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.excludeLabelsOnEdges(ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination)";
       description = "<b>excludeLabelsOnEdges</b><br><br>Removes all labels from a label map which touch the edges of the image (in X, Y and Z if the image is 3D). <br><br>Remaining label elements are renumbered afterwards.<br><br>Parameters:<br>ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.excludeLabelsOnSurface(ClearCLBuffer pointlist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float centerX, Float centerY, Float centerZ)";
       description = "<b>excludeLabelsOnSurface</b><br><br>This operation follows a ray from a given position towards a label (or opposite direction) and checks if  there is another label between the label an the image border. <br><br>If yes, this label is eliminated from the label map.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float centerX, Float centerY, Float centerZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.excludeLabelsOutsideSizeRange(ClearCLBuffer input, ClearCLBuffer destination, Float minimum_size, Float maximum_size)";
       description = "<b>excludeLabelsOutsideSizeRange</b><br><br>Removes labels from a label map which are not within a certain size range.<br><br>Size of the labels is given as the number of pixel or voxels per label.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float minimum_size, Float maximum_size";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.excludeLabelsSubSurface(ClearCLBuffer pointlist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float centerX, Float centerY, Float centerZ)";
       description = "<b>excludeLabelsSubSurface</b><br><br>This operation follows a ray from a given position towards a label (or opposite direction) and checks if  there is another label between the label an the image border. <br><br>If yes, this label is eliminated from the label map.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float centerX, Float centerY, Float centerZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.excludeLabelsWithValuesOutOfRange(ClearCLBuffer values_vector, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float minimum_value_range, Float maximum_value_range)";
       description = "<b>excludeLabelsWithValuesOutOfRange</b><br><br>This operation removes labels from a labelmap and renumbers the remaining labels. <br><br>Hand over a vector of values and a range specifying which labels with which values are eliminated.<br><br>Parameters:<br>ClearCLBuffer values_vector, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float minimum_value_range, Float maximum_value_range";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.excludeLabelsWithValuesWithinRange(ClearCLBuffer values_vector, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float minimum_value_range, Float maximum_value_range)";
       description = "<b>excludeLabelsWithValuesWithinRange</b><br><br>This operation removes labels from a labelmap and renumbers the remaining labels. <br><br>Hand over a vector of values and a range specifying which labels with which values are eliminated.<br><br>Parameters:<br>ClearCLBuffer values_vector, ClearCLBuffer label_map_input, ClearCLBuffer label_map_destination, Float minimum_value_range, Float maximum_value_range";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.exponential(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>exponential</b><br><br>Computes base exponential of all pixels values.<br><br>f(x) = exp(x)<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.extendLabelingViaVoronoi(ClearCLBuffer input, ClearCLImageInterface destination)";
       description = "<b>extendLabelingViaVoronoi</b><br><br>Takes a label map image and dilates the regions using a octagon shape until they touch. <br><br>The resulting label map is written to the output.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.extendLabelsWithMaximumRadius(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3)";
       description = "<b>extendLabelsWithMaximumRadius</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.extendedDepthOfFocusTenengradProjection(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigma)";
       description = "<b>extendedDepthOfFocusTenengradProjection</b><br><br>Extended depth of focus projection maximizing intensity in the local sobel image.<br><br>The sigma parameter allows controlling an Gaussian blur which should smooth the altitude map.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigma";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.extendedDepthOfFocusVarianceProjection(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Float sigma)";
       description = "<b>extendedDepthOfFocusVarianceProjection</b><br><br>Extended depth of focus projection maximizing local pixel intensity variance.<br><br>The sigma parameter allows controlling an Gaussian blur which should smooth the altitude map.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Float sigma";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.extensionRatioMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>extensionRatioMap</b><br><br>Takes a label map, determines for every label the extension ratio and replaces every label with the that number.<br><br>The extension ratio is the maximum distance of any pixel in the label to the label centroid divided by the average distance of all pixels in the label to the centroid.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.fillHistogram(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4)";
       description = "<b>fillHistogram</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.flip(ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flip_x, Boolean flip_y)";
       description = "<b>flip</b><br><br>Flips an image in X and/or Y direction depending on if flip_x and/or flip_y are set to true or false.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flip_x, Boolean flip_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.flip2D(ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flip_x, Boolean flip_y)";
       description = "<b>flip2D</b><br><br>Flips an image in X and/or Y direction depending on if flip_x and/or flip_y are set to true or false.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flip_x, Boolean flip_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.flip3D(ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flip_x, Boolean flip_y, Boolean flip_z)";
       description = "<b>flip3D</b><br><br>Flips an image in X, Y and/or Z direction depending on if flip_x, flip_y and/or flip_z are set to true or false.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Boolean flip_x, Boolean flip_y, Boolean flip_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.floodFillDiamond(ClearCLBuffer source, ClearCLBuffer destination, Float value_to_replace, Float value_replacement)";
       description = "<b>floodFillDiamond</b><br><br>Replaces recursively all pixels of value a with value b if the pixels have a neighbor with value b.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float value_to_replace, Float value_replacement";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.gammaCorrection(ClearCLBuffer input, ClearCLBuffer destination, Float gamma)";
       description = "<b>gammaCorrection</b><br><br>Applies a gamma correction to an image.<br><br>Therefore, all pixels x of the Image X are normalized and the power to gamma g is computed, before normlization is reversed (^ is the power operator):f(x) = (x / max(X)) ^ gamma * max(X)<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float gamma";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.gaussianBlur(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigma_x, Float sigma_y)";
       description = "<b>gaussianBlur</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. <br><br>Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigma_x, Float sigma_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.gaussianBlur2D(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigma_x, Float sigma_y)";
       description = "<b>gaussianBlur2D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X and Y. <br><br>Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigma_x, Float sigma_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.gaussianBlur3D(ClearCLImageInterface source, ClearCLImageInterface destination, Float sigma_x, Float sigma_y, Float sigma_z)";
       description = "<b>gaussianBlur3D</b><br><br>Computes the Gaussian blurred image of an image given two sigma values in X, Y and Z. <br><br>Thus, the filterkernel can have non-isotropic shape.<br><br>The implementation is done separable. In case a sigma equals zero, the direction is not blurred.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float sigma_x, Float sigma_y, Float sigma_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.generateBinaryOverlapMatrix(ClearCLBuffer label_map1, ClearCLBuffer label_map2, ClearCLBuffer binary_overlap_matrix_destination)";
       description = "<b>generateBinaryOverlapMatrix</b><br><br>Takes two labelmaps with n and m labels and generates a (n+1)*(m+1) matrix where all pixels are set to 0 exept those where labels overlap between the label maps. <br><br>For example, if labels 3 in labelmap1 and 4 in labelmap2 are touching then the pixel (3,4) in the matrix will be set to 1.<br><br>Parameters:<br>ClearCLBuffer label_map1, ClearCLBuffer label_map2, ClearCLBuffer binary_overlap_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.generateDistanceMatrix(ClearCLBuffer coordinate_list1, ClearCLBuffer coordinate_list2, ClearCLBuffer distance_matrix_destination)";
       description = "<b>generateDistanceMatrix</b><br><br>Computes the distance between all point coordinates given in two point lists.<br><br>Takes two images containing pointlists (dimensionality n * d, n: number of points and d: dimensionality) and builds up a matrix containing the distances between these points. <br><br>Convention: Given two point lists with dimensionality n * d and m * d, the distance matrix will be of size(n + 1) * (m + 1). The first row and column contain zeros. They represent the distance of the objects to a theoretical background object. In that way, distance matrices are of the same size as touch matrices (see generateTouchMatrix). Thus, one can threshold a distance matrix to generate a touch matrix out of it for drawing meshes.<br><br>Parameters:<br>ClearCLBuffer coordinate_list1, ClearCLBuffer coordinate_list2, ClearCLBuffer distance_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.generateJaccardIndexMatrix(ClearCLBuffer label_map1, ClearCLBuffer label_map2, ClearCLBuffer jaccard_index_matrix_destination)";
       description = "<b>generateJaccardIndexMatrix</b><br><br>Takes two labelmaps with n and m labels_2 and generates a (n+1)*(m+1) matrix where all labels_1 are set to 0 exept those where labels_2 overlap between the label maps. <br><br>For the remaining labels_1, the value will be between 0 and 1 indicating the overlap as measured by the Jaccard Index.<br>Major parts of this operation run on the CPU.<br><br>Parameters:<br>ClearCLBuffer label_map1, ClearCLBuffer label_map2, ClearCLBuffer jaccard_index_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.generateNNearestNeighborsMatrix(ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix_destination, Integer n)";
       description = "<b>generateNNearestNeighborsMatrix</b><br><br>Produces a touch-matrix where the n nearest neighbors are marked as touching neighbors. <br><br>Takes a distance matrix (e.g. derived from a pointlist of centroids) and marks for every column the n smallest<br>distances as neighbors. The resulting matrix can be use as if it was a touch-matrix (a.k.a. adjacency graph matrix). <br><br>Inspired by a similar implementation in imglib2 [1]<br><br>Note: The implementation is limited to square matrices.<br><br>### Parameters<br><br>distance_marix : Image<br>touch_matrix_destination : Image<br>n : int<br>   number of neighbors<br>   <br>References<br>----------<br>[1] https://github.com/imglib/imglib2/blob/master/src/main/java/net/imglib2/interpolation/neighborsearch/InverseDistanceWeightingInterpolator.java<br><br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix_destination, Integer n";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.generateParametricImage(ClearCLImageInterface label_map, ClearCLImageInterface parameter_value_vector, ClearCLImageInterface parametric_image_destination)";
       description = "<b>generateParametricImage</b><br><br>Take a labelmap and a vector of values to replace label 1 with the 1st value in the vector. <br><br>Note that indexing in the vector starts at zero. The 0th entry corresponds to background in the label map.Internally this method just calls ReplaceIntensities.<br><br><br>Parameters:<br>ClearCLImageInterface label_map, ClearCLImageInterface parameter_value_vector, ClearCLImageInterface parametric_image_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.generateParametricImageFromResultsTableColumn(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ResultsTable arg3, String arg4)";
       description = "<b>generateParametricImageFromResultsTableColumn</b><br><br>Take a labelmap and a column from the results table to replace label 1 with the 1st value in the vector. <br><br>Note that indexing in the table column starts at zero. The results table should contain a line at the beginningrepresenting the background.<br><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ResultsTable arg3, String arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.generateProximalNeighborsMatrix(ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix_destination, Float min_distance, Float max_distance)";
       description = "<b>generateProximalNeighborsMatrix</b><br><br>Produces a touch-matrix where the neighbors within a given distance range are marked as touching neighbors.<br><br>Takes a distance matrix (e.g. derived from a pointlist of centroids) and marks for every column the neighbors whose<br>distance lie within a given distance range (>= min and <= max). <br>The resulting matrix can be use as if it was a touch-matrix (a.k.a. adjacency graph matrix). <br><br>### Parameters<br><br>distance_marix : Image<br>touch_matrix_destination : Image<br>min_distance : float, optional<br>    default : 0<br>max_distance : float, optional<br>    default: 10 <br><br>Returns<br>-------<br>touch_matrix_destination<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix_destination, Float min_distance, Float max_distance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.generateTouchCountMatrix(ClearCLBuffer label_map, ClearCLBuffer touch_count_matrix_destination)";
       description = "<b>generateTouchCountMatrix</b><br><br>Takes a label map with n labels and generates a (n+1)*(n+1) matrix where all pixels are set the number of pixels where labels touch (diamond neighborhood). <br><br>Major parts of this operation run on the CPU.<br><br>Parameters:<br>ClearCLBuffer label_map, ClearCLBuffer touch_count_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.generateTouchMatrix(ClearCLBuffer label_map, ClearCLBuffer touch_matrix_destination)";
       description = "<b>generateTouchMatrix</b><br><br>Takes a labelmap with n labels and generates a (n+1)*(n+1) matrix where all pixels are set to 0 exept those where labels are touching. <br><br>Only half of the matrix is filled (with x < y). For example, if labels 3 and 4 are touching then the pixel (3,4) in the matrix will be set to 1.<br>The touch matrix is a representation of a region adjacency graph<br><br><br>Parameters:<br>ClearCLBuffer label_map, ClearCLBuffer touch_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.getAutomaticThreshold(ClearCLBuffer arg1, String arg2)";
       description = "<b>getAutomaticThreshold</b><br><br>Determines a threshold according to a given method and saves it to the threshold_value variable.<br><br>The automatic thresholder utilizes the threshold methods from ImageJ on a histogram determined on <br>the GPU to determine a threshold value as similar as possible to ImageJ 'Apply Threshold' method. <br><br>Enter one <br>of these methods in the method text field:<br>[Default, Huang, Intermodes, IsoData, IJ_IsoData, Li, MaxEntropy, Mean, MinError, Minimum, Moments, Otsu, Percentile, RenyiEntropy, Shanbhag, Triangle, Yen]<br><br>Parameters:<br>ClearCLBuffer arg1, String arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.getBoundingBox(ClearCLBuffer arg1)";
       description = "<b>getBoundingBox</b><br><br>Determines the bounding box of all non-zero pixels in a binary image. <br><br>If called from macro, the positions will be stored in the variables 'boundingBoxX', 'boundingBoxY', 'boundingBoxZ', 'boundingBoxWidth', 'boundingBoxHeight' and 'boundingBoxDepth'.In case of 2D images Z and depth will be zero.<br><br>Parameters:<br>ClearCLBuffer arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.getCenterOfMass(ClearCLBuffer arg1)";
       description = "<b>getCenterOfMass</b><br><br>Determines the center of mass of an image or image stack.<br><br> It writes the result in the variables<br> centerOfMassX, centerOfMassY and centerOfMassZ.<br><br>Parameters:<br>ClearCLBuffer arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.getDimensions(ClearCLBuffer arg1)";
       description = "<b>getDimensions</b><br><br>Reads out the size of an image [stack] and writes it to the variables 'width', 'height' and 'depth'.<br><br>Parameters:<br>ClearCLBuffer arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.getGPUProperties(null)";
       description = "<b>getGPUProperties</b><br><br>Reads out properties of the currently active GPU and write it in the variables 'GPU_name', <br>'global_memory_in_bytes' and 'OpenCL_Version'.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.getJaccardIndex(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>getJaccardIndex</b><br><br>Determines the overlap of two binary images using the Jaccard index. <br><br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The resulting Jaccard index is saved to the results table in the 'Jaccard_Index' column.<br>Note that the Sorensen-Dice coefficient can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.getMaximumOfAllPixels(ClearCLImageInterface arg1)";
       description = "<b>getMaximumOfAllPixels</b><br><br>Determines the maximum of all pixels in a given image. <br><br>It will be stored in the variable maximum_of_all_pixels.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.getMeanOfAllPixels(ClearCLImageInterface arg1)";
       description = "<b>getMeanOfAllPixels</b><br><br>Determines the mean of all pixels in a given image. <br><br>It will be stored in the variable mean_of_all_pixels.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.getMeanOfMaskedPixels(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>getMeanOfMaskedPixels</b><br><br>Determines the mean of all pixels in a given image which have non-zero value in a corresponding mask image. <br><br>It will be stored in the variable mean_of_masked_pixels.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.getMinimumOfAllPixels(ClearCLImageInterface arg1)";
       description = "<b>getMinimumOfAllPixels</b><br><br>Determines the minimum of all pixels in a given image. <br><br>It will be stored in the variable minimum_of_all_pixels.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.getSorensenDiceCoefficient(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>getSorensenDiceCoefficient</b><br><br>Determines the overlap of two binary images using the Sorensen-Dice coefficent. <br><br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The Sorensen-Dice coefficient is saved in the colum 'Sorensen_Dice_coefficient'.<br>Note that the Sorensen-Dice coefficient s can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.getSumOfAllPixels(ClearCLImageInterface arg1)";
       description = "<b>getSumOfAllPixels</b><br><br>Determines the sum of all pixels in a given image. <br><br>It will be stored in the variable sum_of_all_pixels.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.gradientX(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientX</b><br><br>Computes the gradient of gray values along X. <br><br>Assuming a, b and c are three adjacent<br> pixels in X direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.gradientY(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientY</b><br><br>Computes the gradient of gray values along Y. <br><br>Assuming a, b and c are three adjacent<br> pixels in Y direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.gradientZ(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>gradientZ</b><br><br>Computes the gradient of gray values along Z. <br><br>Assuming a, b and c are three adjacent<br> pixels in Z direction. In the target image will be saved as: <pre>b' = c - a;</pre><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.greater(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>greater</b><br><br>Determines if two images A and B greater pixel wise.<br><br>f(a, b) = 1 if a > b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.greaterConstant(ClearCLImageInterface source, ClearCLImageInterface destination, Float constant)";
       description = "<b>greaterConstant</b><br><br>Determines if two images A and B greater pixel wise. <br><br>f(a, b) = 1 if a > b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.greaterOrEqual(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>greaterOrEqual</b><br><br>Determines if two images A and B greater or equal pixel wise. <br><br>f(a, b) = 1 if a >= b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.greaterOrEqualConstant(ClearCLImageInterface source, ClearCLImageInterface destination, Float constant)";
       description = "<b>greaterOrEqualConstant</b><br><br>Determines if two images A and B greater or equal pixel wise. <br><br>f(a, b) = 1 if a >= b; 0 otherwise. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.greyscaleClosingBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>greyscaleClosingBox</b><br><br>Apply a greyscale morphological closing to the input image.<br><br>It applies a maximum filter first and the result is processed by a minimum filter with given radii.<br>Low intensity regions smaller than radius will disappear.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.greyscaleClosingSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>greyscaleClosingSphere</b><br><br>Apply a greyscale morphological closing to the input image.<br><br>It applies a maximum filter first and the result is processed by a minimum filter with given radii.<br>Low intensity regions smaller than radius will disappear.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.greyscaleOpeningBox(ClearCLBuffer source, ClearCLBuffer destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>greyscaleOpeningBox</b><br><br>Apply a greyscale morphological opening to the input image.<br><br>It applies a minimum filter first and the result is processed by a maximum filter with given radii.<br>High intensity regions smaller than radius will disappear.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.greyscaleOpeningSphere(ClearCLBuffer source, ClearCLBuffer destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>greyscaleOpeningSphere</b><br><br>Apply a greyscale morphological opening to the input image.<br><br>It applies a minimum filter first and the result is processed by a maximum filter with given radii.<br>High intensity regions smaller than radius will disappear.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.histogram(ClearCLBuffer source, ClearCLBuffer destination, Integer number_of_bins, Float minimum_intensity, Float maximum_intensity, Boolean determine_min_max)";
       description = "<b>histogram</b><br><br>Determines the histogram of a given image.<br><br>The histogram image is of dimensions number_of_bins/1/1; a 3D image with height=1 and depth=1. <br>Histogram bins contain the number of pixels with intensity in this corresponding bin. <br>The histogram bins are uniformly distributed between given minimum and maximum grey value intensity. <br>If the flag determine_min_max is set, minimum and maximum intensity will be determined. <br>When calling this operation many times, it is recommended to determine minimum and maximum intensity <br>once at the beginning and handing over these values.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer number_of_bins, Float minimum_intensity, Float maximum_intensity, Boolean determine_min_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.image2DToResultsTable(ClearCLBuffer arg1, ResultsTable arg2)";
       description = "<b>image2DToResultsTable</b><br><br>Converts an image into a table.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.imageToStack(ClearCLBuffer source, ClearCLBuffer destination, Integer num_slices)";
       description = "<b>imageToStack</b><br><br>Copies a single slice into a stack a given number of times.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Integer num_slices";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.invalidateKernelCache(null)";
       description = "<b>invalidateKernelCache</b><br><br>Invalidates all cached OpenCL programs and kernels.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.invert(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>invert</b><br><br>Computes the negative value of all pixels in a given image. <br><br>It is recommended to convert images to <br>32-bit float before applying this operation.<br><br><pre>f(x) = - x</pre><br><br>For binary images, use binaryNot.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.jaccardIndex(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>jaccardIndex</b><br><br>Determines the overlap of two binary images using the Jaccard index. <br><br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The resulting Jaccard index is saved to the results table in the 'Jaccard_Index' column.<br>Note that the Sorensen-Dice coefficient can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelMaximumExtensionMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>labelMaximumExtensionMap</b><br><br>Takes a label map, determines for every label the maximum distance of any pixel to the centroid and replaces every label with the that number.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelMaximumExtensionRatioMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>labelMaximumExtensionRatioMap</b><br><br>Takes a label map, determines for every label the extension ratio and replaces every label with the that number.<br><br>The extension ratio is the maximum distance of any pixel in the label to the label centroid divided by the average distance of all pixels in the label to the centroid.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelMaximumIntensityMap(ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination)";
       description = "<b>labelMaximumIntensityMap</b><br><br>Takes an image and a corresponding label map, determines the maximum intensity per label and replaces every label with the that number.<br><br>This results in a parametric image expressing mean object intensity.<br><br>Parameters:<br>ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelMeanExtensionMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>labelMeanExtensionMap</b><br><br>Takes a label map, determines for every label the mean distance of any pixel to the centroid and replaces every label with the that number.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelMeanIntensityMap(ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination)";
       description = "<b>labelMeanIntensityMap</b><br><br>Takes an image and a corresponding label map, determines the mean intensity per label and replaces every label with the that number.<br><br>This results in a parametric image expressing mean object intensity.<br><br>Parameters:<br>ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelMinimumIntensityMap(ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination)";
       description = "<b>labelMinimumIntensityMap</b><br><br>Takes an image and a corresponding label map, determines the minimum intensity per label and replaces every label with the that number.<br><br>This results in a parametric image expressing mean object intensity.<br><br>Parameters:<br>ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelOverlapCountMap(ClearCLBuffer label_map1, ClearCLBuffer label_map2, ClearCLBuffer overlap_count_map_destination)";
       description = "<b>labelOverlapCountMap</b><br><br>Takes two label maps, and counts for every label in label map 1 how many labels overlap with it in label map 2.<br><br>The resulting map is generated from the label map 1 by replacing the labels with the respective count.<br><br>Parameters:<br>ClearCLBuffer label_map1, ClearCLBuffer label_map2, ClearCLBuffer overlap_count_map_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelPixelCountMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>labelPixelCountMap</b><br><br>Takes a label map, determines the number of pixels per label and replaces every label with the that number.<br><br>This results in a parametric image expressing area or volume.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelProximalNeighborCountMap(ClearCLBuffer label_map1, ClearCLBuffer label_map2, ClearCLBuffer proximal_neighbor_count_map_destination, Float min_distance, Float max_distance)";
       description = "<b>labelProximalNeighborCountMap</b><br><br>Takes two label maps, and counts for every label in label map 1 how many labels are in a given distance range to it in label map 2.<br><br>Distances are computed from the centroids of the labels. The resulting map is generated from the label map 1 by replacing the labels with the respective count.<br><br>Parameters:<br>ClearCLBuffer label_map1, ClearCLBuffer label_map2, ClearCLBuffer proximal_neighbor_count_map_destination, Float min_distance, Float max_distance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelSpots(ClearCLBuffer input_spots, ClearCLBuffer labelled_spots_destination)";
       description = "<b>labelSpots</b><br><br>Transforms a binary image with single pixles set to 1 to a labelled spots image. <br><br>Transforms a spots image as resulting from maximum/minimum detection in an image of the same size where every spot has a number 1, 2, ... n.<br><br>Parameters:<br>ClearCLBuffer input_spots, ClearCLBuffer labelled_spots_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelStandardDeviationIntensityMap(ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination)";
       description = "<b>labelStandardDeviationIntensityMap</b><br><br>Takes an image and a corresponding label map, determines the standard deviation of the intensity per label and replaces every label with the that number.<br><br>This results in a parametric image expressing standard deviation of object intensity.<br><br>Parameters:<br>ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelSurface(ClearCLBuffer input_labels, ClearCLBuffer destination_labels, Float relative_center_x, Float relative_center_y, Float relative_center_z)";
       description = "<b>labelSurface</b><br><br>Takes a label map and excludes all labels which are not on the surface.<br><br>For each label, a ray from a given center towards the label. If the ray crosses another label, the labelin question is not at the surface and thus, removed.<br><br>Parameters:<br>ClearCLBuffer input_labels, ClearCLBuffer destination_labels, Float relative_center_x, Float relative_center_y, Float relative_center_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelToMask(ClearCLBuffer label_map_source, ClearCLBuffer mask_destination, Float label_index)";
       description = "<b>labelToMask</b><br><br>Masks a single label in a label map. <br><br>Sets all pixels in the target image to 1, where the given label index was present in the label map. Other pixels are set to 0.<br><br>Parameters:<br>ClearCLBuffer label_map_source, ClearCLBuffer mask_destination, Float label_index";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelVoronoiOctagon(ClearCLBuffer label_map, ClearCLBuffer label_voronoi_destination)";
       description = "<b>labelVoronoiOctagon</b><br><br>Takes a labeled image and dilates the labels using a octagon shape until they touch. <br><br>The pixels where  the regions touched are afterwards returned as binary image which corresponds to the Voronoi diagram.<br><br>Parameters:<br>ClearCLBuffer label_map, ClearCLBuffer label_voronoi_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.labelledSpotsToPointList(ClearCLBuffer input_labelled_spots, ClearCLBuffer destination_pointlist)";
       description = "<b>labelledSpotsToPointList</b><br><br>Generates a coordinate list of points in a labelled spot image. <br><br>Transforms a labelmap of spots (single pixels with values 1, 2, ..., n for n spots) as resulting <br>from connected components analysis in an image where every column contains d <br>pixels (with d = dimensionality of the original image) with the coordinates of the maxima/minima.<br><br>Parameters:<br>ClearCLBuffer input_labelled_spots, ClearCLBuffer destination_pointlist";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.laplaceBox(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>laplaceBox</b><br><br>Applies the Laplace operator (Box neighborhood) to an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.laplaceSphere(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>laplaceSphere</b><br><br>Applies the Laplace operator (Diamond neighborhood) to an image.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.localThreshold(ClearCLImageInterface source, ClearCLImageInterface localThreshold, ClearCLImageInterface destination)";
       description = "<b>localThreshold</b><br><br>Computes a binary image with pixel values 0 and 1 depending on if a pixel value x in image X <br>was above of equal to the pixel value m in mask image M.<br><br><pre>f(x) = (1 if (x >=  m)); (0 otherwise)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface localThreshold, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.logarithm(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>logarithm</b><br><br>Computes base e logarithm of all pixels values.<br><br>f(x) = log(x)<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.makeIsotropic(ClearCLBuffer input, ClearCLBuffer destination, Float original_voxel_size_x, Float original_voxel_size_y, Float original_voxel_size_z, Float new_voxel_size)";
       description = "<b>makeIsotropic</b><br><br>Applies a scaling operation using linear interpolation to generate an image stack with a given isotropic voxel size.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float original_voxel_size_x, Float original_voxel_size_y, Float original_voxel_size_z, Float new_voxel_size";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.mask(ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination)";
       description = "<b>mask</b><br><br>Computes a masked image by applying a binary mask to an image. <br><br>All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same position in the mask image is not equal to <br>zero.<br><br><pre>f(x,m) = (x if (m != 0); (0 otherwise))</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maskLabel(ClearCLBuffer source, ClearCLBuffer label_map, ClearCLBuffer destination, Float label_index)";
       description = "<b>maskLabel</b><br><br>Computes a masked image by applying a label mask to an image. <br><br>All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same position in the label_map image has the right index value i.<br><br>f(x,m,i) = (x if (m == i); (0 otherwise))<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer label_map, ClearCLBuffer destination, Float label_index";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maskStackWithPlane(ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination)";
       description = "<b>maskStackWithPlane</b><br><br>Computes a masked image by applying a binary 2D mask to an image stack. <br><br>All pixel values x of image X will be copied<br>to the destination image in case pixel value m at the same spatial position in the mask image is not equal to <br>zero.<br><br><pre>f(x,m) = (x if (m != 0); (0 otherwise))</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface mask, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maskedVoronoiLabeling(ClearCLBuffer input, ClearCLBuffer mask, ClearCLImageInterface destination)";
       description = "<b>maskedVoronoiLabeling</b><br><br>Takes a binary image, labels connected components and dilates the regions using a octagon shape until they touch and only inside another binary mask image.<br><br>The resulting label map is written to the output.<br><br>Hint: Process isotropic images only.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer mask, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.matrixEqual(ClearCLBuffer input1, ClearCLBuffer input2, Float tolerance)";
       description = "<b>matrixEqual</b><br><br>Checks if all elements of a matrix are different by less than or equal to a given tolerance. <br><br>The result will be put in the results table in column &quot;MatrixEqual&quot; as 1 if yes and 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer input1, ClearCLBuffer input2, Float tolerance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximum2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y)";
       description = "<b>maximum2DBox</b><br><br>Computes the local maximum of a pixels rectangular neighborhood. <br><br>The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximum2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y)";
       description = "<b>maximum2DSphere</b><br><br>Computes the local maximum of a pixels ellipsoidal neighborhood. <br><br>The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximum3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>maximum3DBox</b><br><br>Computes the local maximum of a pixels cube neighborhood. <br><br>The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximum3DSliceBySliceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>maximum3DSliceBySliceSphere</b><br><br>Computes the local maximum of a pixels ellipsoidal 2D neighborhood in an image stack slice by slice. <br><br>The ellipses size is specified by its half-width and half-height (radius).<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximum3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>maximum3DSphere</b><br><br>Computes the local maximum of a pixels spherical neighborhood. <br><br>The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y)";
       description = "<b>maximumBox</b><br><br>Computes the local maximum of a pixels rectangular neighborhood. <br><br>The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumDiamond(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLKernel arg3)";
       description = "<b>maximumDiamond</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumDistanceOfTouchingNeighbors(ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer distancelist_destination)";
       description = "<b>maximumDistanceOfTouchingNeighbors</b><br><br>Takes a touch matrix and a distance matrix to determine the maximum distance of touching neighbors for every object.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer distancelist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumExtensionMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>maximumExtensionMap</b><br><br>Takes a label map, determines for every label the maximum distance of any pixel to the centroid and replaces every label with the that number.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>maximumImageAndScalar</b><br><br>Computes the maximum of a constant scalar s and each pixel value x in a given image X. <br><br><pre>f(x, s) = max(x, s)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumImages(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>maximumImages</b><br><br>Computes the maximum of a pair of pixel values x, y from two given images X and Y. <br><br><pre>f(x, y) = max(x, y)</pre><br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumIntensityMap(ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination)";
       description = "<b>maximumIntensityMap</b><br><br>Takes an image and a corresponding label map, determines the maximum intensity per label and replaces every label with the that number.<br><br>This results in a parametric image expressing mean object intensity.<br><br>Parameters:<br>ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumNeighborDistanceMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>maximumNeighborDistanceMap</b><br><br>Takes a label map, determines which labels touch and replaces every label with the maximum distance to their neighboring labels.<br><br>To determine the distances, the centroid of the labels is determined internally.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumOctagon(ClearCLBuffer input, ClearCLBuffer destination, Integer iterations)";
       description = "<b>maximumOctagon</b><br><br>Applies a maximum filter with kernel size 3x3 n times to an image iteratively. <br><br>Odd iterations are done with box neighborhood, even iterations with a diamond. <br>Thus, with n > 2, the filter shape is an octagon. The given number of iterations makes the filter <br>result very similar to minimum sphere. Approximately:radius = iterations - 2<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer iterations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumOfAllPixels(ClearCLImageInterface source)";
       description = "<b>maximumOfAllPixels</b><br><br>Determines the maximum of all pixels in a given image. <br><br>It will be stored in a new row of ImageJs<br>Results table in the column 'Max'.<br><br>### Parameters<br><br>source : Image<br>    The image of which the maximum of all pixels or voxels will be determined.<br><br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>maximumOfMaskedPixels</b><br><br>Determines the maximum intensity in an image, but only in pixels which have non-zero values in another mask image.<br><br>### Parameters<br><br>source : Image<br>    The image of which the minimum of all pixels or voxels where mask=1 will be determined.<br>mask : Image<br>    A binary image marking all pixels with 1 which should be taken into accout.<br><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumOfNNearestNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer n)";
       description = "<b>maximumOfNNearestNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image<br>by the maximum value of neighboring labels. The distance number of nearest neighbors can be configured.<br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>n : int<br>    number of nearest neighbors<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer n";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumOfProximalNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Float min_distance, Float max_distance)";
       description = "<b>maximumOfProximalNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image by the maximum value of neighboring labels.<br><br> The distance range of the centroids of the neighborhood can be configured.<br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>min_distance : float, optional<br>    default : 0<br>max_distance : float, optional<br>    default: maximum float value<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Float min_distance, Float max_distance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumOfTouchingNeighbors(ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer maximum_values_destination)";
       description = "<b>maximumOfTouchingNeighbors</b><br><br>Takes a touch matrix and a vector of values to determine the maximum value among touching neighbors for every object. <br><br>### Parameters<br><br>values : Image<br>    A vector of values corresponding to the labels of which the maximum should be determined.<br>touch_matrix : Image<br>    A touch_matrix specifying which labels are taken into account for neighborhood relationships.<br>maximum_values_destination : Image<br>    A the resulting vector of maximum values in the neighborhood.<br><br><br>Parameters:<br>ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer maximum_values_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumOfTouchingNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer radius, Boolean ignore_touching_background)";
       description = "<b>maximumOfTouchingNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image<br>by the maximum value of neighboring labels. The radius of the neighborhood can be configured:<br>* radius 0: Nothing is replaced<br>* radius 1: direct neighbors are taken into account<br>* radius 2: neighbors and neighbors or neighbors are taken into account<br>* radius n: ...<br><br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>radius : int<br>ignore_touching_background : bool<br><br>Returns<br>-------<br>parametric_map_destination<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer radius, Boolean ignore_touching_background";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumTouchingNeighborDistanceMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>maximumTouchingNeighborDistanceMap</b><br><br>Takes a label map, determines which labels touch and replaces every label with the maximum distance to their neighboring labels.<br><br>To determine the distances, the centroid of the labels is determined internally.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumXProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max)";
       description = "<b>maximumXProjection</b><br><br>Determines the maximum intensity projection of an image along X.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumYProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max)";
       description = "<b>maximumYProjection</b><br><br>Determines the maximum intensity projection of an image along X.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_max)";
       description = "<b>maximumZProjection</b><br><br>Determines the maximum intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.maximumZProjectionBounded(ClearCLImageInterface source, ClearCLImageInterface destination_max, Integer min_z, Integer max_z)";
       description = "<b>maximumZProjectionBounded</b><br><br>Determines the maximum intensity projection of an image along Z within a given z range.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_max, Integer min_z, Integer max_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.mean2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y)";
       description = "<b>mean2DBox</b><br><br>Computes the local mean average of a pixels rectangular neighborhood. <br><br>The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.mean2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y)";
       description = "<b>mean2DSphere</b><br><br>Computes the local mean average of a pixels ellipsoidal neighborhood. <br><br>The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.mean3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>mean3DBox</b><br><br>Computes the local mean average of a pixels cube neighborhood. <br><br>The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.mean3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>mean3DSphere</b><br><br>Computes the local mean average of a pixels spherical neighborhood. <br><br>The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanBox(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5)";
       description = "<b>meanBox</b><br><br>Computes the local mean average of a pixels rectangular neighborhood. <br><br>The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, Integer arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanClosestSpotDistance(ClearCLBuffer spotsA, ClearCLBuffer spotsB, Boolean bidirectional)";
       description = "<b>meanClosestSpotDistance</b><br><br>Determines the distance between pairs of closest spots in two binary images. <br><br>Takes two binary images A and B with marked spots and determines for each spot in image A the closest spot in image B. Afterwards, it saves the average shortest distances from image A to image B as 'mean_closest_spot_distance_A_B' and from image B to image A as 'mean_closest_spot_distance_B_A' to the results table. The distance between B and A is only determined if the `bidirectional` checkbox is checked.<br><br>Parameters:<br>ClearCLBuffer spotsA, ClearCLBuffer spotsB, Boolean bidirectional";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanExtensionMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>meanExtensionMap</b><br><br>Takes a label map, determines for every label the mean distance of any pixel to the centroid and replaces every label with the that number.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanIntensityMap(ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination)";
       description = "<b>meanIntensityMap</b><br><br>Takes an image and a corresponding label map, determines the mean intensity per label and replaces every label with the that number.<br><br>This results in a parametric image expressing mean object intensity.<br><br>Parameters:<br>ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanOfAllPixels(ClearCLImageInterface source)";
       description = "<b>meanOfAllPixels</b><br><br>Determines the mean average of all pixels in a given image. <br><br>It will be stored in a new row of ImageJs<br>Results table in the column 'Mean'.### Parameters<br><br>source : Image<br>    The image of which the mean average of all pixels or voxels will be determined.<br><br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>meanOfMaskedPixels</b><br><br>Determines the mean intensity in a masked image. <br><br>Only in pixels which have non-zero values in another binary mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanOfNNearestNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer n)";
       description = "<b>meanOfNNearestNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image<br>by the minimum value of neighboring labels. The distance number of nearest neighbors can be configured.<br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>n : int<br>    number of nearest neighbors<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer n";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanOfPixelsAboveThreshold(ClearCLBuffer source, Float threshold)";
       description = "<b>meanOfPixelsAboveThreshold</b><br><br>Determines the mean intensity in a threshleded image. <br><br>But only in pixels which are above a given threshold.<br><br>Parameters:<br>ClearCLBuffer source, Float threshold";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanOfProximalNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Float min_distance, Float max_distance)";
       description = "<b>meanOfProximalNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image by the mean average value of neighboring labels.<br><br> The distance range of the centroids of the neighborhood can be configured.<br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>min_distance : float, optional<br>    default : 0<br>max_distance : float, optional<br>    default: maximum float value<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Float min_distance, Float max_distance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanOfTouchingNeighbors(ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer mean_values_destination)";
       description = "<b>meanOfTouchingNeighbors</b><br><br>Takes a touch matrix and a vector of values to determine the mean value among touching neighbors for every object. <br><br>### Parameters<br><br>values : Image<br>    A vector of values corresponding to the labels of which the mean average should be determined.<br>touch_matrix : Image<br>    A touch_matrix specifying which labels are taken into account for neighborhood relationships.<br>mean_values_destination : Image<br>    A the resulting vector of mean average values in the neighborhood.<br><br><br>Parameters:<br>ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer mean_values_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanOfTouchingNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer radius, Boolean ignore_touching_background)";
       description = "<b>meanOfTouchingNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image<br>by the mean average value of neighboring labels. The radius of the neighborhood can be configured:<br>* radius 0: Nothing is replaced<br>* radius 1: direct neighbors are taken into account<br>* radius 2: neighbors and neighbors or neighbors are taken into account<br>* radius n: ...<br><br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>radius : int<br>ignore_touching_background : bool<br><br>Returns<br>-------<br>parametric_map_destination<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer radius, Boolean ignore_touching_background";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanSliceBySliceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>meanSliceBySliceSphere</b><br><br>Computes the local mean average of a pixels ellipsoidal 2D neighborhood in an image stack <br>slice by slice. <br><br>The ellipses size is specified by its half-width and half-height (radius).<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanSquaredError(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>meanSquaredError</b><br><br>Determines the mean squared error (MSE) between two images. <br><br>The MSE will be stored in a new row of ImageJs<br>Results table in the column 'MSE'.<br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanXProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>meanXProjection</b><br><br>Determines the mean average intensity projection of an image along X.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanYProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>meanYProjection</b><br><br>Determines the mean average intensity projection of an image along Y.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanZProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>meanZProjection</b><br><br>Determines the mean average intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.meanZProjectionBounded(ClearCLImageInterface source, ClearCLImageInterface destination_mean, Integer min_z, Integer max_z)";
       description = "<b>meanZProjectionBounded</b><br><br>Determines the mean average intensity projection of an image along Z within a given z range.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_mean, Integer min_z, Integer max_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.median2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median2DBox</b><br><br>Computes the local median of a pixels rectangular neighborhood. <br><br>The rectangle is specified by <br>its half-width and half-height (radius).<br><br>For technical reasons, the area of the rectangle must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.median2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median2DSphere</b><br><br>Computes the local median of a pixels ellipsoidal neighborhood. <br><br>The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>For technical reasons, the area of the ellipse must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.median3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>median3DBox</b><br><br>Computes the local median of a pixels cuboid neighborhood. <br><br>The cuboid size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>For technical reasons, the volume of the cuboid must contain less than 1000 voxels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.median3DSliceBySliceBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median3DSliceBySliceBox</b><br><br>Computes the local median of a pixels rectangular neighborhood. <br><br>This is done slice-by-slice in a 3D <br>image stack. The rectangle is specified by its half-width and half-height (radius).<br><br>For technical reasons, the area of the rectangle must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.median3DSliceBySliceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>median3DSliceBySliceSphere</b><br><br>Computes the local median of a pixels ellipsoidal neighborhood. <br><br>This is done slice-by-slice in a 3D <br>image stack. The ellipses size is specified by its half-width and half-height (radius).<br><br>For technical reasons, the area of the ellipse must have less than 1000 pixels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.median3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>median3DSphere</b><br><br>Computes the local median of a pixels spherical neighborhood. <br><br>The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>For technical reasons, the volume of the sphere must contain less than 1000 voxels.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.medianOfTouchingNeighbors(ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer median_values_destination)";
       description = "<b>medianOfTouchingNeighbors</b><br><br>Takes a touch matrix and a vector of values to determine the median value among touching neighbors for every object. <br><br><br><br>Parameters:<br>ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer median_values_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.medianZProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>medianZProjection</b><br><br>Determines the median intensity projection of an image stack along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.medianZProjectionMasked(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3)";
       description = "<b>medianZProjectionMasked</b><br><br>Determines the median intensity projection of an image stack along Z where pixels in a corresponding mask image are unequal to zero.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.mergeTouchingLabels(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>mergeTouchingLabels</b><br><br><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimum2DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y)";
       description = "<b>minimum2DBox</b><br><br>Computes the local minimum of a pixels rectangular neighborhood. <br><br>The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimum2DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y)";
       description = "<b>minimum2DSphere</b><br><br>Computes the local minimum of a pixels ellipsoidal neighborhood. <br><br>The ellipses size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimum3DBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>minimum3DBox</b><br><br>Computes the local minimum of a pixels cube neighborhood. <br><br>The cubes size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimum3DSliceBySliceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY)";
       description = "<b>minimum3DSliceBySliceSphere</b><br><br>Computes the local minimum of a pixels ellipsoidal 2D neighborhood in an image stack <br>slice by slice. <br><br>The ellipses size is specified by its half-width and half-height (radius).<br><br>This filter is applied slice by slice in 2D.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radiusX, Integer radiusY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimum3DSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>minimum3DSphere</b><br><br>Computes the local minimum of a pixels spherical neighborhood. <br><br>The spheres size is specified by <br>its half-width, half-height and half-depth (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y)";
       description = "<b>minimumBox</b><br><br>Computes the local minimum of a pixels rectangular neighborhood. <br><br>The rectangles size is specified by <br>its half-width and half-height (radius).<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumDiamond(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLKernel arg3)";
       description = "<b>minimumDiamond</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumDistanceOfTouchingNeighbors(ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer minimum_distancelist_destination)";
       description = "<b>minimumDistanceOfTouchingNeighbors</b><br><br>Takes a touch matrix and a distance matrix to determine the shortest distance of touching neighbors for every object.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer touch_matrix, ClearCLBuffer minimum_distancelist_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>minimumImageAndScalar</b><br><br>Computes the minimum of a constant scalar s and each pixel value x in a given image X.<br><br><pre>f(x, s) = min(x, s)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumImages(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination)";
       description = "<b>minimumImages</b><br><br>Computes the minimum of a pair of pixel values x, y from two given images X and Y.<br><br><pre>f(x, y) = min(x, y)</pre><br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumIntensityMap(ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination)";
       description = "<b>minimumIntensityMap</b><br><br>Takes an image and a corresponding label map, determines the minimum intensity per label and replaces every label with the that number.<br><br>This results in a parametric image expressing mean object intensity.<br><br>Parameters:<br>ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumNeighborDistanceMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>minimumNeighborDistanceMap</b><br><br>Takes a label map, determines which labels touch and replaces every label with the minimum distance to their neighboring labels.<br><br>To determine the distances, the centroid of the labels is determined internally.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumOctagon(ClearCLBuffer input, ClearCLBuffer destination, Integer iterations)";
       description = "<b>minimumOctagon</b><br><br>Applies a minimum filter with kernel size 3x3 n times to an image iteratively. <br><br>Odd iterations are done with box neighborhood, even iterations with a diamond. Thus, with n > 2, the filter shape is an octagon. The given number of iterations makes the filter result very similar to minimum sphere. Approximately:radius = iterations - 2<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer iterations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumOfAllPixels(ClearCLImageInterface source)";
       description = "<b>minimumOfAllPixels</b><br><br>Determines the minimum of all pixels in a given image. <br><br>It will be stored in a new row of ImageJs<br>Results table in the column 'Min'.<br><br>### Parameters<br><br>source : Image<br>    The image of which the minimum of all pixels or voxels will be determined.<br><br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>minimumOfMaskedPixels</b><br><br>Determines the minimum intensity in a masked image. <br><br>But only in pixels which have non-zero values in another mask image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumOfNNearestNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer n)";
       description = "<b>minimumOfNNearestNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image<br>by the minimum value of neighboring labels. The distance number of nearest neighbors can be configured.<br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>n : int<br>    number of nearest neighbors<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer n";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumOfProximalNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Float min_distance, Float max_distance)";
       description = "<b>minimumOfProximalNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image by the minimum value of neighboring labels.<br><br> The distance range of the centroids of the neighborhood can be configured.<br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>min_distance : float, optional<br>    default : 0<br>max_distance : float, optional<br>    default: maximum float value<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Float min_distance, Float max_distance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumOfTouchingNeighbors(ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer minimum_values_destination)";
       description = "<b>minimumOfTouchingNeighbors</b><br><br>Takes a touch matrix and a vector of values to determine the minimum value among touching neighbors for every object. <br><br>### Parameters<br><br>values : Image<br>    A vector of values corresponding to the labels of which the minimum should be determined.<br>touch_matrix : Image<br>    A touch_matrix specifying which labels are taken into account for neighborhood relationships.<br>minimum_values_destination : Image<br>    A the resulting vector of minimum values in the neighborhood.<br><br><br>Parameters:<br>ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer minimum_values_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumOfTouchingNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer radius, Boolean ignore_touching_background)";
       description = "<b>minimumOfTouchingNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image<br>by the minimum value of neighboring labels. The radius of the neighborhood can be configured:<br>* radius 0: Nothing is replaced<br>* radius 1: direct neighbors are taken into account<br>* radius 2: neighbors and neighbors or neighbors are taken into account<br>* radius n: ...<br><br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>radius : int<br>ignore_touching_background : bool<br><br>Returns<br>-------<br>parametric_map_destination<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer radius, Boolean ignore_touching_background";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumTouchingNeighborDistanceMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>minimumTouchingNeighborDistanceMap</b><br><br>Takes a label map, determines which labels touch and replaces every label with the minimum distance to their neighboring labels.<br><br>To determine the distances, the centroid of the labels is determined internally.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumXProjection(ClearCLImageInterface source, ClearCLImageInterface destination_min)";
       description = "<b>minimumXProjection</b><br><br>Determines the minimum intensity projection of an image along Y.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_min";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumYProjection(ClearCLImageInterface source, ClearCLImageInterface destination_min)";
       description = "<b>minimumYProjection</b><br><br>Determines the minimum intensity projection of an image along Y.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_min";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_min)";
       description = "<b>minimumZProjection</b><br><br>Determines the minimum intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_min";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumZProjectionBounded(ClearCLImageInterface source, ClearCLImageInterface destination_min, Integer min_z, Integer max_z)";
       description = "<b>minimumZProjectionBounded</b><br><br>Determines the minimum intensity projection of an image along Z within a given z range.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_min, Integer min_z, Integer max_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.minimumZProjectionThresholdedBounded(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Integer arg4, Integer arg5)";
       description = "<b>minimumZProjectionThresholdedBounded</b><br><br>Determines the minimum intensity projection of all pixels in an image above a given threshold along Z within a given z range.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Integer arg4, Integer arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.modeOfNNearestNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer n)";
       description = "<b>modeOfNNearestNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image<br>by the mode value of neighboring labels. The distance number of nearest neighbors can be configured.<br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>n : int<br>    number of nearest neighbors<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer n";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.modeOfProximalNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Float min_distance, Float max_distance)";
       description = "<b>modeOfProximalNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image by the most popular value of neighboring labels.<br><br> The distance range of the centroids of the neighborhood can be configured.<br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>min_distance : float, optional<br>    default : 0<br>max_distance : float, optional<br>    default: maximum float value<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Float min_distance, Float max_distance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.modeOfTouchingNeighbors(ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer mode_values_destination)";
       description = "<b>modeOfTouchingNeighbors</b><br><br>Takes a touch matrix and a vector of values to determine the most popular integer value among touching neighbors for every object.<br>TODO: This only works for values between 0 and 255 for now.<br><br>Parameters:<br>ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer mode_values_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.modeOfTouchingNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer radius, Boolean ignore_touching_background)";
       description = "<b>modeOfTouchingNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image<br>by the most popular value of neighboring labels. The radius of the neighborhood can be configured:<br>* radius 0: Nothing is replaced<br>* radius 1: direct neighbors are taken into account<br>* radius 2: neighbors and neighbors or neighbors are taken into account<br>* radius n: ...<br><br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>radius : int<br>ignore_touching_background : bool<br><br>Returns<br>-------<br>parametric_map_destination<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer radius, Boolean ignore_touching_background";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.multiplyImageAndCoordinate(ClearCLImageInterface source, ClearCLImageInterface destination, Integer dimension)";
       description = "<b>multiplyImageAndCoordinate</b><br><br>Multiplies all pixel intensities with the x, y or z coordinate, depending on specified dimension.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer dimension";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.multiplyImageAndScalar(ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar)";
       description = "<b>multiplyImageAndScalar</b><br><br>Multiplies all pixels value x in a given image X with a constant scalar s.<br><br><pre>f(x, s) = x * s</pre><br><br>### Parameters<br><br>source : Image<br>    The input image to be multiplied with a constant.<br>destination : Image<br>    The output image where results are written into.<br>scalar : float<br>    The number with which every pixel will be multiplied with.<br><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.multiplyImageStackWithScalars(ClearCLImageInterface arg1, ClearCLImageInterface arg2, float[] arg3)";
       description = "<b>multiplyImageStackWithScalars</b><br><br>Multiplies all pixels value x in a given image X with a constant scalar s from a list of scalars.<br><br><pre>f(x, s) = x * s</pre><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, float[] arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.multiplyImages(ClearCLImageInterface factor1, ClearCLImageInterface factor2, ClearCLImageInterface destination)";
       description = "<b>multiplyImages</b><br><br>Multiplies all pairs of pixel values x and y from two images X and Y.<br><br><pre>f(x, y) = x * y</pre><br><br>### Parameters<br><br>factor1 : Image<br>    The first input image to be multiplied.<br>factor2 : Image<br>    The second image to be multiplied.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLImageInterface factor1, ClearCLImageInterface factor2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.multiplyMatrix(ClearCLBuffer matrix1, ClearCLBuffer matrix2, ClearCLBuffer matrix_destination)";
       description = "<b>multiplyMatrix</b><br><br>Multiplies two matrices with each other.<br><br>Parameters:<br>ClearCLBuffer matrix1, ClearCLBuffer matrix2, ClearCLBuffer matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.multiplyStackWithPlane(ClearCLImageInterface sourceStack, ClearCLImageInterface sourcePlane, ClearCLImageInterface destination)";
       description = "<b>multiplyStackWithPlane</b><br><br>Multiplies all pairs of pixel values x and y from an image stack X and a 2D image Y. <br><br>x and y are at <br>the same spatial position within a plane.<br><br><pre>f(x, y) = x * y</pre><br><br>Parameters:<br>ClearCLImageInterface sourceStack, ClearCLImageInterface sourcePlane, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.nClosestDistances(ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3)";
       description = "<b>nClosestDistances</b><br><br>Determine the n point indices with shortest distance for all points in a distance matrix. <br><br>This corresponds to the n row indices with minimum values for each column of the distance matrix.Returns the n shortest distances in one image and the point indices in another image.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, ClearCLBuffer arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.nClosestPoints(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>nClosestPoints</b><br><br>Determine the n point indices with shortest distance for all points in a distance matrix. <br><br>This corresponds to the n row indices with minimum values for each column of the distance matrix.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.neighborDistanceRangeRatioMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>neighborDistanceRangeRatioMap</b><br><br>Takes a label map, determines which labels touch and replaces every label with the distance range ratio (maximum distance divided by minimum distance) to their neighboring labels.<br><br>To determine the distances, the centroids of the labels is determined internally.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.neighborsOfNeighbors(ClearCLBuffer touch_matrix, ClearCLBuffer neighbor_matrix_destination)";
       description = "<b>neighborsOfNeighbors</b><br><br>Determines neighbors of neigbors from touch matrix and saves the result as a new touch matrix.<br><br>Parameters:<br>ClearCLBuffer touch_matrix, ClearCLBuffer neighbor_matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.nonzeroMaximumBox(ClearCLImageInterface input, ClearCLImageInterface destination)";
       description = "<b>nonzeroMaximumBox</b><br><br>Apply a maximum filter (box shape) to the input image. <br><br>The radius is fixed to 1 and pixels with value 0 are ignored.<br>Note: Pixels with 0 value in the input image will not be overwritten in the output image.<br>Thus, the result image should be initialized by copying the original image in advance.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.nonzeroMaximumDiamond(ClearCLImageInterface input, ClearCLImageInterface destination)";
       description = "<b>nonzeroMaximumDiamond</b><br><br>Apply a maximum filter (diamond shape) to the input image. <br><br>The radius is fixed to 1 and pixels with value 0 are ignored.<br>Note: Pixels with 0 value in the input image will not be overwritten in the output image.<br>Thus, the result image should be initialized by copying the original image in advance.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.nonzeroMinimumBox(ClearCLImageInterface input, ClearCLImageInterface destination)";
       description = "<b>nonzeroMinimumBox</b><br><br>Apply a minimum filter (box shape) to the input image. <br><br>The radius is fixed to 1 and pixels with value 0 are ignored.<br>Note: Pixels with 0 value in the input image will not be overwritten in the output image.<br>Thus, the result image should be initialized by copying the original image in advance.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.nonzeroMinimumDiamond(ClearCLImageInterface input, ClearCLImageInterface destination)";
       description = "<b>nonzeroMinimumDiamond</b><br><br>Apply a minimum filter (diamond shape) to the input image. <br><br>The radius is fixed to 1 and pixels with value 0 are ignored.Note: Pixels with 0 value in the input image will not be overwritten in the output image.<br>Thus, the result image should be initialized by copying the original image in advance.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.notEqual(ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLBuffer destination)";
       description = "<b>notEqual</b><br><br>Determines if two images A and B equal pixel wise.<br><br>f(a, b) = 1 if a != b; 0 otherwise.<br><br>### Parameters<br><br>source1 : Image<br>    The first image to be compared with.<br>source2 : Image<br>    The second image to be compared with the first.<br>destination : Image<br>    The resulting binary image where pixels will be 1 only if source1 and source2 are not equal in the given pixel.<br><br><br>Parameters:<br>ClearCLImageInterface source1, ClearCLImageInterface source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.notEqualConstant(ClearCLBuffer source, ClearCLBuffer destination, Float constant)";
       description = "<b>notEqualConstant</b><br><br>Determines if two images A and B equal pixel wise.<br><br>f(a, b) = 1 if a != b; 0 otherwise.### Parameters<br><br>source : Image<br>    The image where every pixel is compared to the constant.<br>destination : Image<br>    The resulting binary image where pixels will be 1 only if source1 and source2 equal in the given pixel.<br>constant : float<br>    The constant where every pixel is compared to.<br><br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.onlyzeroOverwriteMaximumBox(ClearCLImageInterface input, ClearCLImageInterface destination)";
       description = "<b>onlyzeroOverwriteMaximumBox</b><br><br>Apply a local maximum filter to an image which only overwrites pixels with value 0.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.onlyzeroOverwriteMaximumDiamond(ClearCLImageInterface input, ClearCLImageInterface destination)";
       description = "<b>onlyzeroOverwriteMaximumDiamond</b><br><br>Apply a local maximum filter to an image which only overwrites pixels with value 0.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.openingBox(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_erotions_and_dilations)";
       description = "<b>openingBox</b><br><br>Apply a binary opening to the input image by calling n erosions and n dilations subsequenntly.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_erotions_and_dilations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.openingDiamond(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_erotions_and_dilations)";
       description = "<b>openingDiamond</b><br><br>Apply a binary opening to the input image by calling n erosions and n dilations subsequenntly.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_erotions_and_dilations";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.outOfIntensityRange(ClearCLBuffer arg1, ClearCLImageInterface arg2, Float arg3, Float arg4)";
       description = "<b>outOfIntensityRange</b><br><br>Sets all pixels to 1 if their intensity lies out of a given range, and 0 otherwise.<br><br>Given minimum and maximum are considered part of the range.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLImageInterface arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.paste(ClearCLImageInterface source, ClearCLImageInterface destination, Integer destination_x, Integer destination_y)";
       description = "<b>paste</b><br><br>Pastes an image into another image at a given position.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer destination_x, Integer destination_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.paste2D(ClearCLImageInterface source, ClearCLImageInterface destination, Integer destination_x, Integer destination_y)";
       description = "<b>paste2D</b><br><br>Pastes an image into another image at a given position.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer destination_x, Integer destination_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.paste3D(ClearCLImageInterface source, ClearCLImageInterface destination, Integer destination_x, Integer destination_y, Integer destination_z)";
       description = "<b>paste3D</b><br><br>Pastes an image into another image at a given position.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer destination_x, Integer destination_y, Integer destination_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pixelCountMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>pixelCountMap</b><br><br>Takes a label map, determines the number of pixels per label and replaces every label with the that number.<br><br>This results in a parametric image expressing area or volume.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pointIndexListToMesh(ClearCLBuffer pointlist, ClearCLBuffer indexlist, ClearCLBuffer mesh_destination)";
       description = "<b>pointIndexListToMesh</b><br><br>Meshes all points in a given point list which are indiced in a corresponding index list.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer indexlist, ClearCLBuffer mesh_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pointIndexListToTouchMatrix(ClearCLBuffer indexlist, ClearCLBuffer matrix_destination)";
       description = "<b>pointIndexListToTouchMatrix</b><br><br>Takes a list of point indices to generate a touch matrix (a.k.a. adjacency graph matrix) out of it. <br><br>The list hasa dimensionality of m*n for the points 1... m (0 a.k.a. background is not in this list). In the n rows, there are<br>indices to points which should be connected.<br><br>### Parameters<br><br>indexlist : Image<br>matrix_destination : Image<br><br>Parameters:<br>ClearCLBuffer indexlist, ClearCLBuffer matrix_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pointlistToLabelledSpots(ClearCLBuffer pointlist, ClearCLBuffer spots_destination)";
       description = "<b>pointlistToLabelledSpots</b><br><br>Takes a pointlist with dimensions n times d with n point coordinates in d dimensions and labels corresponding pixels.<br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer spots_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.power(ClearCLImageInterface source, ClearCLImageInterface destination, Float exponent)";
       description = "<b>power</b><br><br>Computes all pixels value x to the power of a given exponent a.<br><br><pre>f(x, a) = x ^ a</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float exponent";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.powerImages(ClearCLBuffer input, ClearCLBuffer exponent, ClearCLBuffer destination)";
       description = "<b>powerImages</b><br><br>Calculates x to the power of y pixel wise of two images X and Y.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer exponent, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.print(ClearCLImageInterface input)";
       description = "<b>print</b><br><br>Visualises an image on standard out (console).<br><br>Parameters:<br>ClearCLImageInterface input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.proximalNeighborCountMap(ClearCLBuffer input, ClearCLBuffer destination, Float min_distance, Float max_distance)";
       description = "<b>proximalNeighborCountMap</b><br><br>Takes a label map, determines which labels are within a given distance range and replaces every label with the number of neighboring labels.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float min_distance, Float max_distance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pull(null)";
       description = "<b>pull</b><br><br>Copies an image specified by its name from GPU memory back to ImageJ and shows it.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pullAsROI(ClearCLBuffer binary_input)";
       description = "<b>pullAsROI</b><br><br>Pulls a binary image from the GPU memory and puts it on the currently active ImageJ window as region of interest.<br><br>Parameters:<br>ClearCLBuffer binary_input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pullBinary(null)";
       description = "<b>pullBinary</b><br><br>Copies a binary image specified by its name from GPU memory back to ImageJ and shows it. This binary image will have 0 and 255 pixel intensities as needed for ImageJ to interpret it as binary.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pullLabelsToROIList(ClearCLBuffer labelmap_input)";
       description = "<b>pullLabelsToROIList</b><br><br>Pulls all labels in a label map as ROIs to a list. <br><br>From ImageJ macro this list is written to the log <br>window. From ImageJ macro conside using pullLabelsToROIManager.<br><br>Parameters:<br>ClearCLBuffer labelmap_input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pullLabelsToROIManager(ClearCLBuffer labelmap_input)";
       description = "<b>pullLabelsToROIManager</b><br><br>Pulls all labels in a label map as ROIs to the ROI manager.<br><br>Parameters:<br>ClearCLBuffer labelmap_input";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pullString(ClearCLImageInterface arg1)";
       description = "<b>pullString</b><br><br>Writes an image into a string.<br><br>Parameters:<br>ClearCLImageInterface arg1";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pullTile(ImagePlus arg1, String arg2, Integer arg3, Integer arg4, Integer arg5, Integer arg6, Integer arg7, Integer arg8, Integer arg9, Integer arg10, Integer arg11)";
       description = "<b>pullTile</b><br><br>Pushes a tile in an image specified by its name, position and size from GPU memory.<br><br>Parameters:<br>ImagePlus arg1, String arg2, Integer arg3, Integer arg4, Integer arg5, Integer arg6, Integer arg7, Integer arg8, Integer arg9, Integer arg10, Integer arg11";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pullToResultsTable(ClearCLBuffer arg1, ResultsTable arg2)";
       description = "<b>pullToResultsTable</b><br><br>Converts an image into a table.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pullToResultsTableColumn(ClearCLBuffer arg1, ResultsTable arg2, String arg3, Boolean arg4)";
       description = "<b>pullToResultsTableColumn</b><br><br>Copies the content of a vector image to a column in the results table.<br>You can configure if new rows should be appended or if existing values should be overwritten.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2, String arg3, Boolean arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.push(null)";
       description = "<b>push</b><br><br>Copies an image specified by its name to GPU memory in order to process it there later.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pushArray(ClearCLBuffer arg1, Object arg2)";
       description = "<b>pushArray</b><br><br>Converts an array to a 3D image stack.<br><br>Parameters:<br>ClearCLBuffer arg1, Object arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pushCurrentSelection(null)";
       description = "<b>pushCurrentSelection</b><br><br>Copies an image specified by its name to GPU memory in order to process it there later.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pushCurrentSlice(null)";
       description = "<b>pushCurrentSlice</b><br><br>Copies an image specified by its name to GPU memory in order to process it there later.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pushCurrentSliceSelection(null)";
       description = "<b>pushCurrentSliceSelection</b><br><br>Copies an image specified by its name to GPU memory in order to process it there later.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pushCurrentZStack(null)";
       description = "<b>pushCurrentZStack</b><br><br>Copies an image specified by its name to GPU memory in order to process it there later.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pushResultsTable(ClearCLBuffer arg1, ResultsTable arg2)";
       description = "<b>pushResultsTable</b><br><br>Converts a table to an image. <br><br>Rows stay rows, columns stay columns.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pushResultsTableColumn(ClearCLBuffer arg1, ResultsTable arg2, String arg3)";
       description = "<b>pushResultsTableColumn</b><br><br>Converts a table column to an image. <br><br>The values are stored in x dimension.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2, String arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pushString(ClearCLBuffer arg1, String arg2)";
       description = "<b>pushString</b><br><br>Converts an string to an image. <br><br>The formatting works with double line breaks for slice switches, single line breaks for y swithces and <br>spaces for x. For example this string is converted to an image with width=4, height=3 and depth=2:<br><br>1 2 3 4<br>5 6 7 8<br>9 0 1 2<br><br>3 4 5 6<br>7 8 9 0<br>1 2 3 4<br><br><br>Parameters:<br>ClearCLBuffer arg1, String arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.pushTile(ClearCLBuffer image, Integer tileIndexX, Integer tileIndexY, Integer tileIndexZ, Integer width, Integer height, Integer depth, Integer marginWidth, Integer marginHeight, Integer image0)";
       description = "<b>pushTile</b><br><br>Push a tile in an image specified by its name, position and size to GPU memory in order to process it there later.<br><br>Parameters:<br>ClearCLBuffer image, Integer tileIndexX, Integer tileIndexY, Integer tileIndexZ, Integer width, Integer height, Integer depth, Integer marginWidth, Integer marginHeight, Integer image0";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.radialProjection(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3)";
       description = "<b>radialProjection</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.readValuesFromMap(ClearCLImageInterface labels, ClearCLImageInterface map_image, ClearCLImageInterface values_destination)";
       description = "<b>readValuesFromMap</b><br><br>Takes a label image and an parametric image and reads parametric values from the labels positions.<br><br>The read intensity valus are stored in a new vector.<br><br>Note: This will only work if all labels have number of voxels == 1 or if all pixels in each label have the same value.<br><br>### Parameters<br><br>labels<br>map_image<br>values_destination<br><br>Parameters:<br>ClearCLImageInterface labels, ClearCLImageInterface map_image, ClearCLImageInterface values_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.readValuesFromPositions(ClearCLImageInterface pointlist, ClearCLImageInterface map_image, ClearCLImageInterface values_destination)";
       description = "<b>readValuesFromPositions</b><br><br>Takes a pointlist and a parametric image and reads parametric values from the positions.<br><br>The read intensity values are stored in a new vector.<br><br>### Parameters<br><br>pointlist<br>map_image<br>values_destination<br><br>Parameters:<br>ClearCLImageInterface pointlist, ClearCLImageInterface map_image, ClearCLImageInterface values_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.reduceLabelsToCentroids(ClearCLBuffer input_labels, ClearCLBuffer destination_labels)";
       description = "<b>reduceLabelsToCentroids</b><br><br>Takes a label map and reduces all labels to their center spots. Label IDs stay and background will be zero.<br><br>Parameters:<br>ClearCLBuffer input_labels, ClearCLBuffer destination_labels";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.reduceLabelsToLabelEdges(ClearCLBuffer input_labels, ClearCLBuffer destination_labels)";
       description = "<b>reduceLabelsToLabelEdges</b><br><br>Takes a label map and reduces all labels to their edges. Label IDs stay the same and background will be zero.<br><br>Parameters:<br>ClearCLBuffer input_labels, ClearCLBuffer destination_labels";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.reduceLabelsToLabelledSpots(ClearCLBuffer input_labels, ClearCLBuffer destination_labels)";
       description = "<b>reduceLabelsToLabelledSpots</b><br><br>Takes a label map and reduces all labels to their center spots. Label IDs stay and background will be zero.<br><br>Parameters:<br>ClearCLBuffer input_labels, ClearCLBuffer destination_labels";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.reduceStack(ClearCLImageInterface input, ClearCLImageInterface destination, Integer reduction_factor, Integer offset)";
       description = "<b>reduceStack</b><br><br>Reduces the number of slices in a stack by a given factor.<br>With the offset you have control which slices stay: <br>* With factor 3 and offset 0, slices 0, 3, 6,... are kept. * With factor 4 and offset 1, slices 1, 5, 9,... are kept.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Integer reduction_factor, Integer offset";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.release(null)";
       description = "<b>release</b><br><br>Frees memory of a specified image in GPU memory.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.replaceIntensities(ClearCLImageInterface input, ClearCLImageInterface new_values_vector, ClearCLImageInterface destination)";
       description = "<b>replaceIntensities</b><br><br>Replaces integer intensities specified in a vector image. <br><br>The vector image must be 3D with size (m, 1, 1) where m corresponds to the maximum intensity in the original image. Assuming the vector image contains values (0, 1, 0, 2) means: <br> * All pixels with value 0 (first entry in the vector image) get value 0<br> * All pixels with value 1 get value 1<br> * All pixels with value 2 get value 0<br> * All pixels with value 3 get value 2<br><br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface new_values_vector, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.replaceIntensity(ClearCLImageInterface input, ClearCLImageInterface destination, Float value_to_replace, Float value_replacement)";
       description = "<b>replaceIntensity</b><br><br>Replaces a specific intensity in an image with a given new value.<br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float value_to_replace, Float value_replacement";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.replacePixelsIfZero(ClearCLImageInterface input1, ClearCLImageInterface input2, ClearCLImageInterface destination)";
       description = "<b>replacePixelsIfZero</b><br><br>Replaces pixel values x with y in case x is zero.<br><br>This functionality is comparable to ImageJs image calculator operator 'transparent zero'.<br><br>Parameters:<br>ClearCLImageInterface input1, ClearCLImageInterface input2, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.reportMemory(null)";
       description = "<b>reportMemory</b><br><br>Prints a list of all images cached in the GPU to ImageJs log window together with a sum of memory <br>consumption.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.resample(ClearCLImageInterface source, ClearCLImageInterface destination, Float factor_x, Float factor_y, Float factor_z, Boolean linear_interpolation)";
       description = "<b>resample</b><br><br>Resamples an image with given size factors using an affine transform.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float factor_x, Float factor_y, Float factor_z, Boolean linear_interpolation";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.resample2D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Boolean arg5)";
       description = "<b>resample2D</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.resample3D(ClearCLImageInterface arg1, ClearCLImageInterface arg2, Float arg3, Float arg4, Float arg5, Boolean arg6)";
       description = "<b>resample3D</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.resliceBottom(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceBottom</b><br><br>Flippes Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method but<br>offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.resliceLeft(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceLeft</b><br><br>Flippes X, Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method <br> but offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.resliceRadial(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3)";
       description = "<b>resliceRadial</b><br><br>Computes a radial projection of an image stack. <br><br>Starting point for the line is the given point in any <br>X/Y-plane of a given input image stack. Furthermore, radius of the resulting projection must be given and scaling factors in X and Y in case pixels are not isotropic.This operation is similar to ImageJs 'Radial Reslice' method but offers less flexibility.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.resliceRadialTop(null)";
       description = "<b>resliceRadialTop</b><br><br>Computes a radial projection of an image stack and reslices it from top. <br><br>Starting point for the line is the given point in any <br>X/Y-plane of a given input image stack. Furthermore, radius of the resulting projection must be given and scaling factors in X and Y in case pixels are not isotropic.This operation is similar to ImageJs 'Radial Reslice' method combined with 'Reslice from top' but offers less flexibility.<br><br>Parameters:<br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.resliceRight(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceRight</b><br><br>Flippes X, Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method <br> but offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.resliceTop(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>resliceTop</b><br><br>Flippes Y and Z axis of an image stack. This operation is similar to ImageJs 'Reslice [/]' method but<br>offers less flexibility such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.resultsTableColumnToImage(ClearCLBuffer arg1, ResultsTable arg2, String arg3)";
       description = "<b>resultsTableColumnToImage</b><br><br>Converts a table column to an image. <br><br>The values are stored in x dimension.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2, String arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.resultsTableToImage2D(ClearCLBuffer arg1, ResultsTable arg2)";
       description = "<b>resultsTableToImage2D</b><br><br>Converts a table to an image. <br><br>Rows stay rows, columns stay columns.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.rigidTransform(ClearCLBuffer input, ClearCLBuffer destination, Float translation_x, Float translation_y, Float translation_z, Float rotation_angle_x, Float rotation_angle_y, Float rotation_angle_z)";
       description = "<b>rigidTransform</b><br><br>Applies a rigid transform using linear interpolation to an image stack.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float translation_x, Float translation_y, Float translation_z, Float rotation_angle_x, Float rotation_angle_y, Float rotation_angle_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.rotate2D(ClearCLBuffer source, ClearCLBuffer destination, Float angle, Boolean rotateAroundCenter)";
       description = "<b>rotate2D</b><br><br>Rotates an image in plane. <br><br>All angles are entered in degrees. If the image is not rotated around <br>the center, it is rotated around the coordinate origin.<br><br>It is recommended to apply the rotation to an isotropic image.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float angle, Boolean rotateAroundCenter";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.rotate3D(ClearCLBuffer source, ClearCLBuffer destination, Float angleX, Float angleY, Float angleZ, Boolean rotateAroundCenter)";
       description = "<b>rotate3D</b><br><br>Rotates an image stack in 3D. <br><br>All angles are entered in degrees. If the image is not rotated around <br>the center, it is rotated around the coordinate origin.<br><br>It is recommended to apply the rotation to an isotropic image stack.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float angleX, Float angleY, Float angleZ, Boolean rotateAroundCenter";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.rotateClockwise(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateClockwise</b><br><br>Rotates a given input image by 90 degrees clockwise. <br><br>For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.rotateCounterClockwise(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateCounterClockwise</b><br><br>Rotates a given input image by 90 degrees counter-clockwise. <br><br>For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.rotateLeft(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateLeft</b><br><br>Rotates a given input image by 90 degrees counter-clockwise. <br><br>For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.rotateRight(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>rotateRight</b><br><br>Rotates a given input image by 90 degrees counter-clockwise. <br><br>For that, X and Y axis of an image stack<br>are flipped. This operation is similar to ImageJs 'Reslice [/]' method but offers less flexibility <br>such as interpolation.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.saveAsTIF(ClearCLBuffer input, String filename)";
       description = "<b>saveAsTIF</b><br><br>Pulls an image from the GPU memory and saves it as TIF to disc.<br><br>Parameters:<br>ClearCLBuffer input, String filename";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.scale(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3)";
       description = "<b>scale</b><br><br>Scales an image with a given factor.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.scale2D(ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4)";
       description = "<b>scale2D</b><br><br>Scales an image with a given factor.<br><br>Parameters:<br>ClearCLBuffer arg1, ClearCLBuffer arg2, Float arg3, Float arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.scale3D(ClearCLBuffer source, ClearCLBuffer destination, Float scaling_factor_x, Float scaling_factor_y, Float scaling_factor_z, Boolean scale_to_center)";
       description = "<b>scale3D</b><br><br>Scales an image with a given factor.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float scaling_factor_x, Float scaling_factor_y, Float scaling_factor_z, Boolean scale_to_center";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.set(ClearCLImageInterface source, Float value)";
       description = "<b>set</b><br><br>Sets all pixel values x of a given image X to a constant value v.<br><br><pre>f(x) = v</pre><br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.setColumn(ClearCLImageInterface source, Integer column_index, Float value)";
       description = "<b>setColumn</b><br><br>Sets all pixel values x of a given column in X to a constant value v.<br><br>Parameters:<br>ClearCLImageInterface source, Integer column_index, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.setImageBorders(ClearCLImageInterface destination, Float value)";
       description = "<b>setImageBorders</b><br><br>Sets all pixel values at the image border to a given value.<br><br>Parameters:<br>ClearCLImageInterface destination, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.setNonZeroPixelsToPixelIndex(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>setNonZeroPixelsToPixelIndex</b><br><br>Sets all pixels in an image which are not zero to the index of the pixel. <br><br>This can be used for Connected Components Analysis.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.setPlane(ClearCLImageInterface source, Integer plane_index, Float value)";
       description = "<b>setPlane</b><br><br>Sets all pixel values x of a given plane in X to a constant value v.<br><br>Parameters:<br>ClearCLImageInterface source, Integer plane_index, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.setRampX(ClearCLImageInterface source)";
       description = "<b>setRampX</b><br><br>Sets all pixel values to their X coordinate<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.setRampY(ClearCLImageInterface source)";
       description = "<b>setRampY</b><br><br>Sets all pixel values to their Y coordinate<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.setRampZ(ClearCLImageInterface source)";
       description = "<b>setRampZ</b><br><br>Sets all pixel values to their Z coordinate<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.setRandom(ClearCLBuffer source, Float minimumValue, Float maximumValue, Float seed)";
       description = "<b>setRandom</b><br><br>Fills an image or image stack with uniformly distributed random numbers between given minimum and maximum values. <br><br>Recommendation: For the seed, use getTime().<br><br>Parameters:<br>ClearCLBuffer source, Float minimumValue, Float maximumValue, Float seed";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.setRow(ClearCLImageInterface source, Integer row_index, Float value)";
       description = "<b>setRow</b><br><br>Sets all pixel values x of a given row in X to a constant value v.<br><br>Parameters:<br>ClearCLImageInterface source, Integer row_index, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.setWhereXequalsY(ClearCLImageInterface source, Float value)";
       description = "<b>setWhereXequalsY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x == y. <br><br>Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.setWhereXgreaterThanY(ClearCLImageInterface source, Float value)";
       description = "<b>setWhereXgreaterThanY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x > y. <br><br>Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.setWhereXsmallerThanY(ClearCLImageInterface source, Float value)";
       description = "<b>setWhereXsmallerThanY</b><br><br>Sets all pixel values a of a given image A to a constant value v in case its coordinates x < y. <br><br>Otherwise the pixel is not overwritten.<br>If you want to initialize an identity transfrom matrix, set all pixels to 0 first.<br><br>Parameters:<br>ClearCLImageInterface source, Float value";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.shiftIntensitiesToCloseGaps(ClearCLBuffer arg1, ClearCLBuffer arg2)";
       description = "<b>shiftIntensitiesToCloseGaps</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.shortestDistances(ClearCLBuffer distance_matrix, ClearCLBuffer destination_minimum_distances)";
       description = "<b>shortestDistances</b><br><br>Determine the shortest distance from a distance matrix. <br><br>This corresponds to the minimum for each individial column.<br><br>Parameters:<br>ClearCLBuffer distance_matrix, ClearCLBuffer destination_minimum_distances";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.shrinkLabels(ClearCLBuffer labels_input, ClearCLBuffer labels_destination, Integer radius, Boolean relabel_islands)";
       description = "<b>shrinkLabels</b><br><br>Extend labels with a given radius.<br><br>This is actually a local minimum filter applied to a label map after introducing background-gaps between labels.<br>In case relabel_islands is set, split objects will get new labels each. In this case, more labels might be in the result.<br>It is recommended to apply this operation to isotropic images only.<br>Warning: If labels were too small, they may be missing in the resulting label image.<br><br>Parameters:<br>ClearCLBuffer labels_input, ClearCLBuffer labels_destination, Integer radius, Boolean relabel_islands";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.similar(ClearCLBuffer input_image1, ClearCLBuffer input_image2, ClearCLBuffer binary_destination, Float tolerance)";
       description = "<b>similar</b><br><br>Determines the absolute difference between two images and sets all pixels to 1 where it is below or equal a given tolerance, and 0 otherwise.<br><br>Parameters:<br>ClearCLBuffer input_image1, ClearCLBuffer input_image2, ClearCLBuffer binary_destination, Float tolerance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.sinus(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>sinus</b><br><br>Computes the sinus of all pixels value x.<br><br><pre>f(x) = sin(x)</pre><br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.smaller(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination)";
       description = "<b>smaller</b><br><br>Determines if two images A and B smaller pixel wise.<br><br>f(a, b) = 1 if a < b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.smallerConstant(ClearCLBuffer source, ClearCLBuffer destination, Float constant)";
       description = "<b>smallerConstant</b><br><br>Determines if two images A and B smaller pixel wise.<br><br>f(a, b) = 1 if a < b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.smallerOrEqual(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination)";
       description = "<b>smallerOrEqual</b><br><br>Determines if two images A and B smaller or equal pixel wise.<br><br>f(a, b) = 1 if a <= b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.smallerOrEqualConstant(ClearCLBuffer source, ClearCLBuffer destination, Float constant)";
       description = "<b>smallerOrEqualConstant</b><br><br>Determines if two images A and B smaller or equal pixel wise.<br><br>f(a, b) = 1 if a <= b; 0 otherwise. <br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float constant";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.sobel(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>sobel</b><br><br>Convolve the image with the Sobel kernel.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.sobelSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>sobelSliceBySlice</b><br><br>Convolve the image with the Sobel kernel slice by slice.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.sorensenDiceCoefficient(ClearCLBuffer source1, ClearCLBuffer source2)";
       description = "<b>sorensenDiceCoefficient</b><br><br>Determines the overlap of two binary images using the Sorensen-Dice coefficent. <br><br>A value of 0 suggests no overlap, 1 means perfect overlap.<br>The Sorensen-Dice coefficient is saved in the colum 'Sorensen_Dice_coefficient'.<br>Note that the Sorensen-Dice coefficient s can be calculated from the Jaccard index j using this formula:<br><pre>s = f(j) = 2 j / (j + 1)</pre><br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.sphereTransform(ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_angles, Float delta_angle_in_degrees, Float relative_center_x, Float relative_center_y, Float relative_center_z)";
       description = "<b>sphereTransform</b><br><br>Turns an image stack in XYZ cartesian coordinate system to an AID polar coordinate system.<br><br>A corresponds to azimut,I to inclination and D to the distance from the center.Thus, going in virtual Z direction (actually D) in the resulting stack, you go from the center to theperiphery.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer number_of_angles, Float delta_angle_in_degrees, Float relative_center_x, Float relative_center_y, Float relative_center_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.spotsToPointList(ClearCLBuffer input_spots, ClearCLBuffer destination_pointlist)";
       description = "<b>spotsToPointList</b><br><br>Transforms a spots image as resulting from maximum/minimum detection in an image where every column contains d <br>pixels (with d = dimensionality of the original image) with the coordinates of the maxima/minima.<br><br>Parameters:<br>ClearCLBuffer input_spots, ClearCLBuffer destination_pointlist";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.squaredDifference(ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination)";
       description = "<b>squaredDifference</b><br><br>Determines the squared difference pixel by pixel between two images.<br><br>Parameters:<br>ClearCLBuffer source1, ClearCLBuffer source2, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.stackToTiles(ClearCLImageInterface source, ClearCLImageInterface destination, Integer tiles_x, Integer tiles_y)";
       description = "<b>stackToTiles</b><br><br>Stack to tiles.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer tiles_x, Integer tiles_y";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.standardDeviationBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>standardDeviationBox</b><br><br>Computes the local standard deviation of a pixels box neighborhood. <br><br>The box size is specified by <br>its half-width, half-height and half-depth (radius). If 2D images are given, radius_z will be ignored. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.standardDeviationIntensityMap(ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination)";
       description = "<b>standardDeviationIntensityMap</b><br><br>Takes an image and a corresponding label map, determines the standard deviation of the intensity per label and replaces every label with the that number.<br><br>This results in a parametric image expressing standard deviation of object intensity.<br><br>Parameters:<br>ClearCLBuffer intensity_image, ClearCLBuffer label_map, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.standardDeviationOfAllPixels(ClearCLImageInterface source)";
       description = "<b>standardDeviationOfAllPixels</b><br><br>Determines the standard deviation of all pixels in an image. <br><br>The value will be stored in a new row of ImageJs<br>Results table in the column 'Standard_deviation'.<br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.standardDeviationOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>standardDeviationOfMaskedPixels</b><br><br>Determines the standard deviation of all pixels in an image which have non-zero value in a corresponding mask image. <br><br>The value will be stored in a new row of ImageJs<br>Results table in the column 'Masked_standard_deviation'.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.standardDeviationOfNNearestNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer n)";
       description = "<b>standardDeviationOfNNearestNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image<br>by the standard deviation value of neighboring labels. The distance number of nearest neighbors can be configured.<br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>n : int<br>    number of nearest neighbors<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer n";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.standardDeviationOfProximalNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Float min_distance, Float max_distance)";
       description = "<b>standardDeviationOfProximalNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image by the standard deviation value of neighboring labels.<br><br> The distance range of the centroids of the neighborhood can be configured.<br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>min_distance : float, optional<br>    default : 0<br>max_distance : float, optional<br>    default: maximum float value<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Float min_distance, Float max_distance";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.standardDeviationOfTouchingNeighbors(ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer standard_deviation_values_destination)";
       description = "<b>standardDeviationOfTouchingNeighbors</b><br><br>Takes a touch matrix and a vector of values to determine the standard deviation value among touching neighbors for every object. <br><br><br><br>Parameters:<br>ClearCLBuffer values, ClearCLBuffer touch_matrix, ClearCLBuffer standard_deviation_values_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.standardDeviationOfTouchingNeighborsMap(ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer radius, Boolean ignore_touching_background)";
       description = "<b>standardDeviationOfTouchingNeighborsMap</b><br><br>Takes a label image and a parametric intensity image and will replace each labels value in the parametric image<br>by the standard deviation value of touching neighbor labels. The radius of the neighborhood can be configured:<br>* radius 0: Nothing is replaced<br>* radius 1: direct neighbors are taken into account<br>* radius 2: neighbors and neighbors or neighbors are taken into account<br>* radius n: ...<br><br>Note: Values of all pixels in a label each must be identical.<br><br>### Parameters<br><br>parametric_map : Image<br>label_map : Image<br>parametric_map_destination : Image<br>radius : int<br>ignore_touching_background : bool<br><br>Returns<br>-------<br>parametric_map_destination<br><br>Parameters:<br>ClearCLBuffer parametric_map, ClearCLBuffer label_map, ClearCLBuffer parametric_map_destination, Integer radius, Boolean ignore_touching_background";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.standardDeviationSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>standardDeviationSphere</b><br><br>Computes the local standard deviation of a pixels spherical neighborhood. <br><br>The spheres size is specified by <br>its half-width, half-height and half-depth (radius). If 2D images are given, radius_z will be ignored. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.standardDeviationZProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>standardDeviationZProjection</b><br><br>Determines the standard deviation intensity projection of an image stack along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.statisticsOfBackgroundAndLabelledPixels(ClearCLBuffer input, ClearCLBuffer labelmap)";
       description = "<b>statisticsOfBackgroundAndLabelledPixels</b><br><br>Determines bounding box, area (in pixels/voxels), min, max and mean intensity <br> of background and labelled objects in a label map and corresponding pixels in the original image.<br><br>Instead of a label map, you can also use a binary image as a binary image is a label map with just one label.<br><br>This method is executed on the CPU and not on the GPU/OpenCL device.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer labelmap";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.statisticsOfImage(ClearCLBuffer arg1, ResultsTable arg2)";
       description = "<b>statisticsOfImage</b><br><br>Determines image size (bounding box), area (in pixels/voxels), min, max and mean intensity <br> of all pixels in the original image.<br><br>This method is executed on the CPU and not on the GPU/OpenCL device.<br><br>Parameters:<br>ClearCLBuffer arg1, ResultsTable arg2";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.statisticsOfLabelledPixels(ClearCLBuffer input, ClearCLBuffer labelmap)";
       description = "<b>statisticsOfLabelledPixels</b><br><br>Determines bounding box, area (in pixels/voxels), min, max and mean intensity <br> of labelled objects in a label map and corresponding pixels in the original image. <br><br>Instead of a label map, you can also use a binary image as a binary image is a label map with just one label.<br><br>This method is executed on the CPU and not on the GPU/OpenCL device.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer labelmap";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.statisticsOfLabelledPixels_single_threaded(ClearCLBuffer arg1, ClearCLBuffer arg2, Integer arg3, Integer arg4)";
       description = "<b>statisticsOfLabelledPixels_single_threaded</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.subStack(ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4)";
       description = "<b>subStack</b><br><br>Crops multiple Z-slices of a 3D stack into a new 3D stack.<br><br><br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, int arg3, int arg4";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.subtract(ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination)";
       description = "<b>subtract</b><br><br>Subtracts one image X from another image Y pixel wise.<br><br><pre>f(x, y) = x - y</pre><br><br>Parameters:<br>ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.subtractImageFromScalar(ClearCLImageInterface input, ClearCLImageInterface destination, Float scalar)";
       description = "<b>subtractImageFromScalar</b><br><br>Subtracts one image X from a scalar s pixel wise.<br><br><pre>f(x, s) = s - x</pre><br><br>Parameters:<br>ClearCLImageInterface input, ClearCLImageInterface destination, Float scalar";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.subtractImages(ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination)";
       description = "<b>subtractImages</b><br><br>Subtracts one image X from another image Y pixel wise.<br><br><pre>f(x, y) = x - y</pre><br><br>Parameters:<br>ClearCLImageInterface subtrahend, ClearCLImageInterface minuend, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.sumImageSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>sumImageSliceBySlice</b><br><br>Sums all pixels slice by slice and returns the sums in a vector.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.sumOfAllPixels(ClearCLImageInterface source)";
       description = "<b>sumOfAllPixels</b><br><br>Determines the sum of all pixels in a given image. <br><br>It will be stored in a new row of ImageJs<br>Results table in the column 'Sum'.<br><br>### Parameters<br><br>source : Image<br>    The image of which all pixels or voxels will be summed.<br><br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.sumPixels(ClearCLImageInterface source)";
       description = "<b>sumPixels</b><br><br>Determines the sum of all pixels in a given image. <br><br>It will be stored in a new row of ImageJs<br>Results table in the column 'Sum'.<br><br>### Parameters<br><br>source : Image<br>    The image of which all pixels or voxels will be summed.<br><br><br>Parameters:<br>ClearCLImageInterface source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.sumPixelsSliceByslice(ClearCLImageInterface arg1)";
       description = "<b>sumPixelsSliceByslice</b><br><br>null";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.sumXProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>sumXProjection</b><br><br>Determines the sum intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.sumYProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>sumYProjection</b><br><br>Determines the sum intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.sumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination_sum)";
       description = "<b>sumZProjection</b><br><br>Determines the sum intensity projection of an image along Z.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination_sum";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.tenengrad(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>tenengrad</b><br><br>Convolve the image with the Tenengrad kernel slice by slice.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.tenengradSliceBySlice(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>tenengradSliceBySlice</b><br><br>Convolve the image with the Tenengrad kernel slice by slice.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.threshold(ClearCLImageInterface source, ClearCLImageInterface destination, Float threshold)";
       description = "<b>threshold</b><br><br>Computes a binary image with pixel values 0 and 1. <br><br>All pixel values x of a given input image with <br>value larger or equal to a given threshold t will be set to 1.<br><br>f(x,t) = (1 if (x >= t); (0 otherwise))<br><br>This plugin is comparable to setting a raw threshold in ImageJ and using the 'Convert to Mask' menu.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Float threshold";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdDefault(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdDefault</b><br><br>The automatic thresholder utilizes the Default threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdHuang(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdHuang</b><br><br>The automatic thresholder utilizes the Huang threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdIJ_IsoData(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdIJ_IsoData</b><br><br>The automatic thresholder utilizes the IJ_IsoData threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdIntermodes(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdIntermodes</b><br><br>The automatic thresholder utilizes the Intermodes threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdIsoData(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdIsoData</b><br><br>The automatic thresholder utilizes the IsoData threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdLi(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdLi</b><br><br>The automatic thresholder utilizes the Li threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdMaxEntropy(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMaxEntropy</b><br><br>The automatic thresholder utilizes the MaxEntropy threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdMean(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMean</b><br><br>The automatic thresholder utilizes the Mean threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdMinError(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMinError</b><br><br>The automatic thresholder utilizes the MinError threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdMinimum(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMinimum</b><br><br>The automatic thresholder utilizes the Minimum threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdMoments(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdMoments</b><br><br>The automatic thresholder utilizes the Moments threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdOtsu(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdOtsu</b><br><br>The automatic thresholder utilizes the Otsu threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdPercentile(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdPercentile</b><br><br>The automatic thresholder utilizes the Percentile threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdRenyiEntropy(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdRenyiEntropy</b><br><br>The automatic thresholder utilizes the RenyiEntropy threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdShanbhag(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdShanbhag</b><br><br>The automatic thresholder utilizes the Shanbhag threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdTriangle(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdTriangle</b><br><br>The automatic thresholder utilizes the Triangle threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.thresholdYen(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>thresholdYen</b><br><br>The automatic thresholder utilizes the Yen threshold method implemented in ImageJ using a histogram determined on <br>the GPU to create binary images as similar as possible to ImageJ 'Apply Threshold' method.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.topHatBox(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>topHatBox</b><br><br>Applies a top-hat filter for background subtraction to the input image.<br><br>### Parameters<br><br>input : Image<br>    The input image where the background is subtracted from.<br>destination : Image<br>    The output image where results are written into.<br>radius_x : Image<br>    Radius of the background determination region in X.<br>radius_y : Image<br>    Radius of the background determination region in Y.<br>radius_z : Image<br>    Radius of the background determination region in Z.<br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.topHatSphere(ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ)";
       description = "<b>topHatSphere</b><br><br>Applies a top-hat filter for background subtraction to the input image.<br><br>### Parameters<br><br>input : Image<br>    The input image where the background is subtracted from.<br>destination : Image<br>    The output image where results are written into.<br>radius_x : Image<br>    Radius of the background determination region in X.<br>radius_y : Image<br>    Radius of the background determination region in Y.<br>radius_z : Image<br>    Radius of the background determination region in Z.<br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Integer radiusX, Integer radiusY, Integer radiusZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.touchMatrixToAdjacencyMatrix(ClearCLBuffer touch_matrix, ClearCLBuffer adjacency_matrix)";
       description = "<b>touchMatrixToAdjacencyMatrix</b><br><br>Converts a touch matrix in an adjacency matrix<br><br>Parameters:<br>ClearCLBuffer touch_matrix, ClearCLBuffer adjacency_matrix";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.touchMatrixToMesh(ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, ClearCLBuffer mesh_destination)";
       description = "<b>touchMatrixToMesh</b><br><br>Takes a pointlist with dimensions n*d with n point coordinates in d dimensions and a touch matrix of <br>size n*n to draw lines from all points to points if the corresponding pixel in the touch matrix is 1.<br><br>### Parameters<br><br>pointlist : Image<br>    n*d matrix representing n coordinates with d dimensions.<br>touch_matrix : Image<br>    A 2D binary matrix with 1 in pixels (i,j) where label i touches label j.<br>mesh_destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLBuffer pointlist, ClearCLBuffer touch_matrix, ClearCLBuffer mesh_destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.touchingNeighborCountMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>touchingNeighborCountMap</b><br><br>Takes a label map, determines which labels touch and replaces every label with the number of touching neighbor labels.<br><br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.touchingNeighborDistanceRangeRatioMap(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>touchingNeighborDistanceRangeRatioMap</b><br><br>Takes a label map, determines which labels touch and replaces every label with the distance range ratio (maximum distance divided by minimum distance) to their neighboring labels.<br><br>To determine the distances, the centroids of the labels is determined internally.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.translate2D(ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY)";
       description = "<b>translate2D</b><br><br>Translate an image stack in X and Y.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.translate3D(ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY, Float translateZ)";
       description = "<b>translate3D</b><br><br>Translate an image stack in X, Y and Z.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination, Float translateX, Float translateY, Float translateZ";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.transposeXY(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>transposeXY</b><br><br>Transpose X and Y axes of an image.<br><br>### Parameters<br><br>input : Image<br>    The input image.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.transposeXZ(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>transposeXZ</b><br><br>Transpose X and Z axes of an image.<br><br>### Parameters<br><br>input : Image<br>    The input image.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.transposeYZ(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>transposeYZ</b><br><br>Transpose Y and Z axes of an image.<br><br>### Parameters<br><br>input : Image<br>    The input image.<br>destination : Image<br>    The output image where results are written into.<br><br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.undefinedToZero(ClearCLBuffer source, ClearCLBuffer destination)";
       description = "<b>undefinedToZero</b><br><br>Copies all pixels instead those which are not a number (NaN) or infinity (inf), which are replaced by 0.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.varianceBox(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>varianceBox</b><br><br>Computes the local variance of a pixels box neighborhood. <br><br>The box size is specified by <br>its half-width, half-height and half-depth (radius). If 2D images are given, radius_z will be ignored. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.varianceOfAllPixels(ClearCLBuffer source)";
       description = "<b>varianceOfAllPixels</b><br><br>Determines the variance of all pixels in an image. <br><br>The value will be stored in a new row of ImageJs<br>Results table in the column 'Variance'.<br><br>Parameters:<br>ClearCLBuffer source";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.varianceOfMaskedPixels(ClearCLBuffer source, ClearCLBuffer mask)";
       description = "<b>varianceOfMaskedPixels</b><br><br>Determines the variance in an image, but only in pixels which have non-zero values in another binary mask image. <br><br>The result is put in the results table as new column named 'Masked_variance'.<br><br>Parameters:<br>ClearCLBuffer source, ClearCLBuffer mask";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.varianceSphere(ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z)";
       description = "<b>varianceSphere</b><br><br>Computes the local variance of a pixels spherical neighborhood. <br><br>The spheres size is specified by <br>its half-width, half-height and half-depth (radius). If 2D images are given, radius_z will be ignored. <br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination, Integer radius_x, Integer radius_y, Integer radius_z";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.visualizeOutlinesOnOriginal(ClearCLBuffer intensity, ClearCLBuffer labels, ClearCLBuffer destination)";
       description = "<b>visualizeOutlinesOnOriginal</b><br><br>Combines an intensity image and a label (or binary) image so that you can see segmentation outlines on the intensity image.<br><br>Parameters:<br>ClearCLBuffer intensity, ClearCLBuffer labels, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.voronoiLabeling(ClearCLBuffer input, ClearCLImageInterface destination)";
       description = "<b>voronoiLabeling</b><br><br>Takes a binary image, labels connected components and dilates the regions using a octagon shape until they touch. <br><br>The resulting label map is written to the output.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.voronoiOctagon(ClearCLBuffer input, ClearCLBuffer destination)";
       description = "<b>voronoiOctagon</b><br><br>Takes a binary image and dilates the regions using a octagon shape until they touch. <br><br>The pixels where  the regions touched are afterwards returned as binary image which corresponds to the Voronoi diagram.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.voronoiOtsuLabeling(ClearCLBuffer input, ClearCLBuffer destination, Float spot_sigma, Float outline_sigma)";
       description = "<b>voronoiOtsuLabeling</b><br><br>Labeles objects directly from grey-value images.<br><br>The two sigma parameters allow tuning the segmentation result. The first sigma controls how close detected cells can be (spot_sigma) and the second controls how precise segmented objects are outlined (outline_sigma).Under the hood, this filter applies two Gaussian blurs, spot detection, Otsu-thresholding and Voronoi-labeling.<br>The thresholded binary image is flooded using the Voronoi approach starting from the found local maxima.<br>Noise-removal sigma for spot detection and thresholding can be configured separately.<br><br>Parameters:<br>ClearCLBuffer input, ClearCLBuffer destination, Float spot_sigma, Float outline_sigma";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.watershed(ClearCLBuffer binary_source, ClearCLBuffer destination)";
       description = "<b>watershed</b><br><br>Apply a binary watershed to a binary image and introduces black pixels between objects.<br><br>Note: This parallel GPU-accelerated approach delivers results of limited quality.See the web for alternatives: https://github.com/clij/clij2/issues/18<br><br>Parameters:<br>ClearCLBuffer binary_source, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.writeValuesToPositions(ClearCLBuffer positions_and_values, ClearCLBuffer destination)";
       description = "<b>writeValuesToPositions</b><br><br>Takes an image with three/four rows (2D: height = 3; 3D: height = 4): x, y [, z] and v and target image. <br><br>The value v will be written at position x/y[/z] in the target image.<br><br>Parameters:<br>ClearCLBuffer positions_and_values, ClearCLBuffer destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.zPositionOfMaximumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>zPositionOfMaximumZProjection</b><br><br>Determines a Z-position of the maximum intensity along Z and writes it into the resulting image.<br><br>If there are multiple z-slices with the same value, the smallest Z will be chosen.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.zPositionOfMinimumZProjection(ClearCLImageInterface source, ClearCLImageInterface destination)";
       description = "<b>zPositionOfMinimumZProjection</b><br><br>Determines a Z-position of the minimum intensity along Z and writes it into the resulting image.<br><br>If there are multiple z-slices with the same value, the smallest Z will be chosen.<br><br>Parameters:<br>ClearCLImageInterface source, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.zPositionProjection(ClearCLImageInterface source_stack, ClearCLImageInterface z_position, ClearCLImageInterface destination)";
       description = "<b>zPositionProjection</b><br><br>Project a defined Z-slice of a 3D stack into a 2D image.<br><br>Which Z-slice is defined as the z_position image, which represents an altitude map.<br><br>Parameters:<br>ClearCLImageInterface source_stack, ClearCLImageInterface z_position, ClearCLImageInterface destination";
       list.add(new BasicCompletion(provider, headline, null, description));
       headline = "clij2.zPositionRangeProjection(ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, int arg4, int arg5)";
       description = "<b>zPositionRangeProjection</b><br><br>Project multiple Z-slices of a 3D stack into a new 3D stack.<br><br>Which Z-slice is defined as the z_position image, which represents an altitude map. The two additional numbers define the range relative to the given z-position.<br><br>Parameters:<br>ClearCLImageInterface arg1, ClearCLImageInterface arg2, ClearCLImageInterface arg3, int arg4, int arg5";
       list.add(new BasicCompletion(provider, headline, null, description));
        return list;
    }
}
// 468 methods generated.
